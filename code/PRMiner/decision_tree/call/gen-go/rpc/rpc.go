// Code generated by Thrift Compiler (0.17.0). DO NOT EDIT.

package rpc

import (
	"bytes"
	"context"
	"errors"
	"fmt"
	thrift "github.com/apache/thrift/lib/go/thrift"
	"time"
)

// (needed to ensure safety because of naive import list construction.)
var _ = thrift.ZERO
var _ = fmt.Printf
var _ = errors.New
var _ = context.Background
var _ = time.Now
var _ = bytes.Equal

// Attributes:
//   - Feature
//   - SplitValue
//   - LeftWeight
//   - RightWeight
//   - LeftImpurity
//   - RightImpurity
//   - ImprovementProxy
type SplitRecord struct {
	Feature          int32   `thrift:"feature,1" db:"feature" json:"feature"`
	SplitValue       float64 `thrift:"splitValue,2" db:"splitValue" json:"splitValue"`
	LeftWeight       float64 `thrift:"leftWeight,3" db:"leftWeight" json:"leftWeight"`
	RightWeight      float64 `thrift:"rightWeight,4" db:"rightWeight" json:"rightWeight"`
	LeftImpurity     float64 `thrift:"leftImpurity,5" db:"leftImpurity" json:"leftImpurity"`
	RightImpurity    float64 `thrift:"rightImpurity,6" db:"rightImpurity" json:"rightImpurity"`
	ImprovementProxy float64 `thrift:"improvementProxy,7" db:"improvementProxy" json:"improvementProxy"`
}

func NewSplitRecord() *SplitRecord {
	return &SplitRecord{}
}

func (p *SplitRecord) GetFeature() int32 {
	return p.Feature
}

func (p *SplitRecord) GetSplitValue() float64 {
	return p.SplitValue
}

func (p *SplitRecord) GetLeftWeight() float64 {
	return p.LeftWeight
}

func (p *SplitRecord) GetRightWeight() float64 {
	return p.RightWeight
}

func (p *SplitRecord) GetLeftImpurity() float64 {
	return p.LeftImpurity
}

func (p *SplitRecord) GetRightImpurity() float64 {
	return p.RightImpurity
}

func (p *SplitRecord) GetImprovementProxy() float64 {
	return p.ImprovementProxy
}
func (p *SplitRecord) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.DOUBLE {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.DOUBLE {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 4:
			if fieldTypeId == thrift.DOUBLE {
				if err := p.ReadField4(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 5:
			if fieldTypeId == thrift.DOUBLE {
				if err := p.ReadField5(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 6:
			if fieldTypeId == thrift.DOUBLE {
				if err := p.ReadField6(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 7:
			if fieldTypeId == thrift.DOUBLE {
				if err := p.ReadField7(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *SplitRecord) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Feature = v
	}
	return nil
}

func (p *SplitRecord) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadDouble(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.SplitValue = v
	}
	return nil
}

func (p *SplitRecord) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadDouble(ctx); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.LeftWeight = v
	}
	return nil
}

func (p *SplitRecord) ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadDouble(ctx); err != nil {
		return thrift.PrependError("error reading field 4: ", err)
	} else {
		p.RightWeight = v
	}
	return nil
}

func (p *SplitRecord) ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadDouble(ctx); err != nil {
		return thrift.PrependError("error reading field 5: ", err)
	} else {
		p.LeftImpurity = v
	}
	return nil
}

func (p *SplitRecord) ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadDouble(ctx); err != nil {
		return thrift.PrependError("error reading field 6: ", err)
	} else {
		p.RightImpurity = v
	}
	return nil
}

func (p *SplitRecord) ReadField7(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadDouble(ctx); err != nil {
		return thrift.PrependError("error reading field 7: ", err)
	} else {
		p.ImprovementProxy = v
	}
	return nil
}

func (p *SplitRecord) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "SplitRecord"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField3(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField4(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField5(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField6(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField7(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *SplitRecord) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "feature", thrift.I32, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:feature: ", p), err)
	}
	if err := oprot.WriteI32(ctx, int32(p.Feature)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.feature (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:feature: ", p), err)
	}
	return err
}

func (p *SplitRecord) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "splitValue", thrift.DOUBLE, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:splitValue: ", p), err)
	}
	if err := oprot.WriteDouble(ctx, float64(p.SplitValue)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.splitValue (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:splitValue: ", p), err)
	}
	return err
}

func (p *SplitRecord) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "leftWeight", thrift.DOUBLE, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:leftWeight: ", p), err)
	}
	if err := oprot.WriteDouble(ctx, float64(p.LeftWeight)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.leftWeight (3) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:leftWeight: ", p), err)
	}
	return err
}

func (p *SplitRecord) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "rightWeight", thrift.DOUBLE, 4); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:rightWeight: ", p), err)
	}
	if err := oprot.WriteDouble(ctx, float64(p.RightWeight)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.rightWeight (4) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 4:rightWeight: ", p), err)
	}
	return err
}

func (p *SplitRecord) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "leftImpurity", thrift.DOUBLE, 5); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:leftImpurity: ", p), err)
	}
	if err := oprot.WriteDouble(ctx, float64(p.LeftImpurity)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.leftImpurity (5) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 5:leftImpurity: ", p), err)
	}
	return err
}

func (p *SplitRecord) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "rightImpurity", thrift.DOUBLE, 6); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:rightImpurity: ", p), err)
	}
	if err := oprot.WriteDouble(ctx, float64(p.RightImpurity)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.rightImpurity (6) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 6:rightImpurity: ", p), err)
	}
	return err
}

func (p *SplitRecord) writeField7(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "improvementProxy", thrift.DOUBLE, 7); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 7:improvementProxy: ", p), err)
	}
	if err := oprot.WriteDouble(ctx, float64(p.ImprovementProxy)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.improvementProxy (7) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 7:improvementProxy: ", p), err)
	}
	return err
}

func (p *SplitRecord) Equals(other *SplitRecord) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.Feature != other.Feature {
		return false
	}
	if p.SplitValue != other.SplitValue {
		return false
	}
	if p.LeftWeight != other.LeftWeight {
		return false
	}
	if p.RightWeight != other.RightWeight {
		return false
	}
	if p.LeftImpurity != other.LeftImpurity {
		return false
	}
	if p.RightImpurity != other.RightImpurity {
		return false
	}
	if p.ImprovementProxy != other.ImprovementProxy {
		return false
	}
	return true
}

func (p *SplitRecord) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SplitRecord(%+v)", *p)
}

// AttrBasic 一些关于属性的简单统计信息
//
// Attributes:
//   - Empty
//   - NaNWeights
//   - Min
//   - Max
//   - Values
//   - ValidClassWeightCount
type AttrBasic struct {
	Empty                 bool                `thrift:"empty,1" db:"empty" json:"empty"`
	NaNWeights            float64             `thrift:"NaNWeights,2" db:"NaNWeights" json:"NaNWeights"`
	Min                   float64             `thrift:"min,3" db:"min" json:"min"`
	Max                   float64             `thrift:"max,4" db:"max" json:"max"`
	Values                []float64           `thrift:"values,5" db:"values" json:"values"`
	ValidClassWeightCount map[float64]float64 `thrift:"validClassWeightCount,6" db:"validClassWeightCount" json:"validClassWeightCount"`
}

func NewAttrBasic() *AttrBasic {
	return &AttrBasic{}
}

func (p *AttrBasic) GetEmpty() bool {
	return p.Empty
}

func (p *AttrBasic) GetNaNWeights() float64 {
	return p.NaNWeights
}

func (p *AttrBasic) GetMin() float64 {
	return p.Min
}

func (p *AttrBasic) GetMax() float64 {
	return p.Max
}

func (p *AttrBasic) GetValues() []float64 {
	return p.Values
}

func (p *AttrBasic) GetValidClassWeightCount() map[float64]float64 {
	return p.ValidClassWeightCount
}
func (p *AttrBasic) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.BOOL {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.DOUBLE {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.DOUBLE {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 4:
			if fieldTypeId == thrift.DOUBLE {
				if err := p.ReadField4(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 5:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField5(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 6:
			if fieldTypeId == thrift.MAP {
				if err := p.ReadField6(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *AttrBasic) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Empty = v
	}
	return nil
}

func (p *AttrBasic) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadDouble(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.NaNWeights = v
	}
	return nil
}

func (p *AttrBasic) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadDouble(ctx); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.Min = v
	}
	return nil
}

func (p *AttrBasic) ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadDouble(ctx); err != nil {
		return thrift.PrependError("error reading field 4: ", err)
	} else {
		p.Max = v
	}
	return nil
}

func (p *AttrBasic) ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]float64, 0, size)
	p.Values = tSlice
	for i := 0; i < size; i++ {
		var _elem0 float64
		if v, err := iprot.ReadDouble(ctx); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_elem0 = v
		}
		p.Values = append(p.Values, _elem0)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *AttrBasic) ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading map begin: ", err)
	}
	tMap := make(map[float64]float64, size)
	p.ValidClassWeightCount = tMap
	for i := 0; i < size; i++ {
		var _key1 float64
		if v, err := iprot.ReadDouble(ctx); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_key1 = v
		}
		var _val2 float64
		if v, err := iprot.ReadDouble(ctx); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_val2 = v
		}
		p.ValidClassWeightCount[_key1] = _val2
	}
	if err := iprot.ReadMapEnd(ctx); err != nil {
		return thrift.PrependError("error reading map end: ", err)
	}
	return nil
}

func (p *AttrBasic) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "AttrBasic"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField3(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField4(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField5(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField6(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *AttrBasic) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "empty", thrift.BOOL, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:empty: ", p), err)
	}
	if err := oprot.WriteBool(ctx, bool(p.Empty)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.empty (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:empty: ", p), err)
	}
	return err
}

func (p *AttrBasic) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "NaNWeights", thrift.DOUBLE, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:NaNWeights: ", p), err)
	}
	if err := oprot.WriteDouble(ctx, float64(p.NaNWeights)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.NaNWeights (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:NaNWeights: ", p), err)
	}
	return err
}

func (p *AttrBasic) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "min", thrift.DOUBLE, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:min: ", p), err)
	}
	if err := oprot.WriteDouble(ctx, float64(p.Min)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.min (3) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:min: ", p), err)
	}
	return err
}

func (p *AttrBasic) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "max", thrift.DOUBLE, 4); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:max: ", p), err)
	}
	if err := oprot.WriteDouble(ctx, float64(p.Max)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.max (4) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 4:max: ", p), err)
	}
	return err
}

func (p *AttrBasic) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "values", thrift.LIST, 5); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:values: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.DOUBLE, len(p.Values)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.Values {
		if err := oprot.WriteDouble(ctx, float64(v)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 5:values: ", p), err)
	}
	return err
}

func (p *AttrBasic) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "validClassWeightCount", thrift.MAP, 6); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:validClassWeightCount: ", p), err)
	}
	if err := oprot.WriteMapBegin(ctx, thrift.DOUBLE, thrift.DOUBLE, len(p.ValidClassWeightCount)); err != nil {
		return thrift.PrependError("error writing map begin: ", err)
	}
	for k, v := range p.ValidClassWeightCount {
		if err := oprot.WriteDouble(ctx, float64(k)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
		}
		if err := oprot.WriteDouble(ctx, float64(v)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
		}
	}
	if err := oprot.WriteMapEnd(ctx); err != nil {
		return thrift.PrependError("error writing map end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 6:validClassWeightCount: ", p), err)
	}
	return err
}

func (p *AttrBasic) Equals(other *AttrBasic) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.Empty != other.Empty {
		return false
	}
	if p.NaNWeights != other.NaNWeights {
		return false
	}
	if p.Min != other.Min {
		return false
	}
	if p.Max != other.Max {
		return false
	}
	if len(p.Values) != len(other.Values) {
		return false
	}
	for i, _tgt := range p.Values {
		_src3 := other.Values[i]
		if _tgt != _src3 {
			return false
		}
	}
	if len(p.ValidClassWeightCount) != len(other.ValidClassWeightCount) {
		return false
	}
	for k, _tgt := range p.ValidClassWeightCount {
		_src4 := other.ValidClassWeightCount[k]
		if _tgt != _src4 {
			return false
		}
	}
	return true
}

func (p *AttrBasic) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AttrBasic(%+v)", *p)
}

// InsBasic 关于实例的一些简单统计信息
//
// Attributes:
//   - SingleCount
//   - MultiCount
//   - Weights
//   - ClassSingleCount
//   - ClassMultiCount
type PartitionInsBasic struct {
	SingleCount      int64             `thrift:"singleCount,1" db:"singleCount" json:"singleCount"`
	MultiCount       int64             `thrift:"multiCount,2" db:"multiCount" json:"multiCount"`
	Weights          float64           `thrift:"weights,3" db:"weights" json:"weights"`
	ClassSingleCount map[float64]int64 `thrift:"classSingleCount,4" db:"classSingleCount" json:"classSingleCount"`
	ClassMultiCount  map[float64]int64 `thrift:"classMultiCount,5" db:"classMultiCount" json:"classMultiCount"`
}

func NewPartitionInsBasic() *PartitionInsBasic {
	return &PartitionInsBasic{}
}

func (p *PartitionInsBasic) GetSingleCount() int64 {
	return p.SingleCount
}

func (p *PartitionInsBasic) GetMultiCount() int64 {
	return p.MultiCount
}

func (p *PartitionInsBasic) GetWeights() float64 {
	return p.Weights
}

func (p *PartitionInsBasic) GetClassSingleCount() map[float64]int64 {
	return p.ClassSingleCount
}

func (p *PartitionInsBasic) GetClassMultiCount() map[float64]int64 {
	return p.ClassMultiCount
}
func (p *PartitionInsBasic) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.DOUBLE {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 4:
			if fieldTypeId == thrift.MAP {
				if err := p.ReadField4(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 5:
			if fieldTypeId == thrift.MAP {
				if err := p.ReadField5(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *PartitionInsBasic) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.SingleCount = v
	}
	return nil
}

func (p *PartitionInsBasic) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.MultiCount = v
	}
	return nil
}

func (p *PartitionInsBasic) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadDouble(ctx); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.Weights = v
	}
	return nil
}

func (p *PartitionInsBasic) ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading map begin: ", err)
	}
	tMap := make(map[float64]int64, size)
	p.ClassSingleCount = tMap
	for i := 0; i < size; i++ {
		var _key5 float64
		if v, err := iprot.ReadDouble(ctx); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_key5 = v
		}
		var _val6 int64
		if v, err := iprot.ReadI64(ctx); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_val6 = v
		}
		p.ClassSingleCount[_key5] = _val6
	}
	if err := iprot.ReadMapEnd(ctx); err != nil {
		return thrift.PrependError("error reading map end: ", err)
	}
	return nil
}

func (p *PartitionInsBasic) ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading map begin: ", err)
	}
	tMap := make(map[float64]int64, size)
	p.ClassMultiCount = tMap
	for i := 0; i < size; i++ {
		var _key7 float64
		if v, err := iprot.ReadDouble(ctx); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_key7 = v
		}
		var _val8 int64
		if v, err := iprot.ReadI64(ctx); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_val8 = v
		}
		p.ClassMultiCount[_key7] = _val8
	}
	if err := iprot.ReadMapEnd(ctx); err != nil {
		return thrift.PrependError("error reading map end: ", err)
	}
	return nil
}

func (p *PartitionInsBasic) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "PartitionInsBasic"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField3(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField4(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField5(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *PartitionInsBasic) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "singleCount", thrift.I64, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:singleCount: ", p), err)
	}
	if err := oprot.WriteI64(ctx, int64(p.SingleCount)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.singleCount (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:singleCount: ", p), err)
	}
	return err
}

func (p *PartitionInsBasic) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "multiCount", thrift.I64, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:multiCount: ", p), err)
	}
	if err := oprot.WriteI64(ctx, int64(p.MultiCount)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.multiCount (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:multiCount: ", p), err)
	}
	return err
}

func (p *PartitionInsBasic) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "weights", thrift.DOUBLE, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:weights: ", p), err)
	}
	if err := oprot.WriteDouble(ctx, float64(p.Weights)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.weights (3) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:weights: ", p), err)
	}
	return err
}

func (p *PartitionInsBasic) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "classSingleCount", thrift.MAP, 4); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:classSingleCount: ", p), err)
	}
	if err := oprot.WriteMapBegin(ctx, thrift.DOUBLE, thrift.I64, len(p.ClassSingleCount)); err != nil {
		return thrift.PrependError("error writing map begin: ", err)
	}
	for k, v := range p.ClassSingleCount {
		if err := oprot.WriteDouble(ctx, float64(k)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
		}
		if err := oprot.WriteI64(ctx, int64(v)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
		}
	}
	if err := oprot.WriteMapEnd(ctx); err != nil {
		return thrift.PrependError("error writing map end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 4:classSingleCount: ", p), err)
	}
	return err
}

func (p *PartitionInsBasic) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "classMultiCount", thrift.MAP, 5); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:classMultiCount: ", p), err)
	}
	if err := oprot.WriteMapBegin(ctx, thrift.DOUBLE, thrift.I64, len(p.ClassMultiCount)); err != nil {
		return thrift.PrependError("error writing map begin: ", err)
	}
	for k, v := range p.ClassMultiCount {
		if err := oprot.WriteDouble(ctx, float64(k)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
		}
		if err := oprot.WriteI64(ctx, int64(v)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
		}
	}
	if err := oprot.WriteMapEnd(ctx); err != nil {
		return thrift.PrependError("error writing map end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 5:classMultiCount: ", p), err)
	}
	return err
}

func (p *PartitionInsBasic) Equals(other *PartitionInsBasic) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.SingleCount != other.SingleCount {
		return false
	}
	if p.MultiCount != other.MultiCount {
		return false
	}
	if p.Weights != other.Weights {
		return false
	}
	if len(p.ClassSingleCount) != len(other.ClassSingleCount) {
		return false
	}
	for k, _tgt := range p.ClassSingleCount {
		_src9 := other.ClassSingleCount[k]
		if _tgt != _src9 {
			return false
		}
	}
	if len(p.ClassMultiCount) != len(other.ClassMultiCount) {
		return false
	}
	for k, _tgt := range p.ClassMultiCount {
		_src10 := other.ClassMultiCount[k]
		if _tgt != _src10 {
			return false
		}
	}
	return true
}

func (p *PartitionInsBasic) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("PartitionInsBasic(%+v)", *p)
}

// Attributes:
//   - Left
//   - Right
type Interval struct {
	Left  float64 `thrift:"left,1" db:"left" json:"left"`
	Right float64 `thrift:"right,2" db:"right" json:"right"`
}

func NewInterval() *Interval {
	return &Interval{}
}

func (p *Interval) GetLeft() float64 {
	return p.Left
}

func (p *Interval) GetRight() float64 {
	return p.Right
}
func (p *Interval) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.DOUBLE {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.DOUBLE {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *Interval) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadDouble(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Left = v
	}
	return nil
}

func (p *Interval) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadDouble(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.Right = v
	}
	return nil
}

func (p *Interval) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "Interval"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *Interval) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "left", thrift.DOUBLE, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:left: ", p), err)
	}
	if err := oprot.WriteDouble(ctx, float64(p.Left)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.left (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:left: ", p), err)
	}
	return err
}

func (p *Interval) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "right", thrift.DOUBLE, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:right: ", p), err)
	}
	if err := oprot.WriteDouble(ctx, float64(p.Right)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.right (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:right: ", p), err)
	}
	return err
}

func (p *Interval) Equals(other *Interval) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.Left != other.Left {
		return false
	}
	if p.Right != other.Right {
		return false
	}
	return true
}

func (p *Interval) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("Interval(%+v)", *p)
}

// Attributes:
//   - AttrT
//   - Attr
//   - NanCount
//   - AttrVs
//   - LabelCount
type AVC struct {
	AttrT      int8                  `thrift:"attrT,1" db:"attrT" json:"attrT"`
	Attr       int32                 `thrift:"attr,2" db:"attr" json:"attr"`
	NanCount   float64               `thrift:"nanCount,3" db:"nanCount" json:"nanCount"`
	AttrVs     []float64             `thrift:"attrVs,4" db:"attrVs" json:"attrVs"`
	LabelCount []map[float64]float64 `thrift:"labelCount,5" db:"labelCount" json:"labelCount"`
}

func NewAVC() *AVC {
	return &AVC{}
}

func (p *AVC) GetAttrT() int8 {
	return p.AttrT
}

func (p *AVC) GetAttr() int32 {
	return p.Attr
}

func (p *AVC) GetNanCount() float64 {
	return p.NanCount
}

func (p *AVC) GetAttrVs() []float64 {
	return p.AttrVs
}

func (p *AVC) GetLabelCount() []map[float64]float64 {
	return p.LabelCount
}
func (p *AVC) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.BYTE {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.DOUBLE {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 4:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField4(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 5:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField5(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *AVC) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadByte(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		temp := int8(v)
		p.AttrT = temp
	}
	return nil
}

func (p *AVC) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.Attr = v
	}
	return nil
}

func (p *AVC) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadDouble(ctx); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.NanCount = v
	}
	return nil
}

func (p *AVC) ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]float64, 0, size)
	p.AttrVs = tSlice
	for i := 0; i < size; i++ {
		var _elem11 float64
		if v, err := iprot.ReadDouble(ctx); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_elem11 = v
		}
		p.AttrVs = append(p.AttrVs, _elem11)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *AVC) ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]map[float64]float64, 0, size)
	p.LabelCount = tSlice
	for i := 0; i < size; i++ {
		_, _, size, err := iprot.ReadMapBegin(ctx)
		if err != nil {
			return thrift.PrependError("error reading map begin: ", err)
		}
		tMap := make(map[float64]float64, size)
		_elem12 := tMap
		for i := 0; i < size; i++ {
			var _key13 float64
			if v, err := iprot.ReadDouble(ctx); err != nil {
				return thrift.PrependError("error reading field 0: ", err)
			} else {
				_key13 = v
			}
			var _val14 float64
			if v, err := iprot.ReadDouble(ctx); err != nil {
				return thrift.PrependError("error reading field 0: ", err)
			} else {
				_val14 = v
			}
			_elem12[_key13] = _val14
		}
		if err := iprot.ReadMapEnd(ctx); err != nil {
			return thrift.PrependError("error reading map end: ", err)
		}
		p.LabelCount = append(p.LabelCount, _elem12)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *AVC) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "AVC"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField3(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField4(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField5(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *AVC) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "attrT", thrift.BYTE, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:attrT: ", p), err)
	}
	if err := oprot.WriteByte(ctx, int8(p.AttrT)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.attrT (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:attrT: ", p), err)
	}
	return err
}

func (p *AVC) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "attr", thrift.I32, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:attr: ", p), err)
	}
	if err := oprot.WriteI32(ctx, int32(p.Attr)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.attr (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:attr: ", p), err)
	}
	return err
}

func (p *AVC) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "nanCount", thrift.DOUBLE, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:nanCount: ", p), err)
	}
	if err := oprot.WriteDouble(ctx, float64(p.NanCount)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.nanCount (3) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:nanCount: ", p), err)
	}
	return err
}

func (p *AVC) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "attrVs", thrift.LIST, 4); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:attrVs: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.DOUBLE, len(p.AttrVs)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.AttrVs {
		if err := oprot.WriteDouble(ctx, float64(v)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 4:attrVs: ", p), err)
	}
	return err
}

func (p *AVC) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "labelCount", thrift.LIST, 5); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:labelCount: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.MAP, len(p.LabelCount)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.LabelCount {
		if err := oprot.WriteMapBegin(ctx, thrift.DOUBLE, thrift.DOUBLE, len(v)); err != nil {
			return thrift.PrependError("error writing map begin: ", err)
		}
		for k, v := range v {
			if err := oprot.WriteDouble(ctx, float64(k)); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
			}
			if err := oprot.WriteDouble(ctx, float64(v)); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
			}
		}
		if err := oprot.WriteMapEnd(ctx); err != nil {
			return thrift.PrependError("error writing map end: ", err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 5:labelCount: ", p), err)
	}
	return err
}

func (p *AVC) Equals(other *AVC) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.AttrT != other.AttrT {
		return false
	}
	if p.Attr != other.Attr {
		return false
	}
	if p.NanCount != other.NanCount {
		return false
	}
	if len(p.AttrVs) != len(other.AttrVs) {
		return false
	}
	for i, _tgt := range p.AttrVs {
		_src15 := other.AttrVs[i]
		if _tgt != _src15 {
			return false
		}
	}
	if len(p.LabelCount) != len(other.LabelCount) {
		return false
	}
	for i, _tgt := range p.LabelCount {
		_src16 := other.LabelCount[i]
		if len(_tgt) != len(_src16) {
			return false
		}
		for k, _tgt := range _tgt {
			_src17 := _src16[k]
			if _tgt != _src17 {
				return false
			}
		}
	}
	return true
}

func (p *AVC) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AVC(%+v)", *p)
}

// Attributes:
//   - SplitId
//   - IsLeft
type PartitionRef struct {
	SplitId int64 `thrift:"splitId,1" db:"splitId" json:"splitId"`
	IsLeft  bool  `thrift:"isLeft,2" db:"isLeft" json:"isLeft"`
}

func NewPartitionRef() *PartitionRef {
	return &PartitionRef{}
}

func (p *PartitionRef) GetSplitId() int64 {
	return p.SplitId
}

func (p *PartitionRef) GetIsLeft() bool {
	return p.IsLeft
}
func (p *PartitionRef) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.BOOL {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *PartitionRef) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.SplitId = v
	}
	return nil
}

func (p *PartitionRef) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.IsLeft = v
	}
	return nil
}

func (p *PartitionRef) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "PartitionRef"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *PartitionRef) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "splitId", thrift.I64, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:splitId: ", p), err)
	}
	if err := oprot.WriteI64(ctx, int64(p.SplitId)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.splitId (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:splitId: ", p), err)
	}
	return err
}

func (p *PartitionRef) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "isLeft", thrift.BOOL, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:isLeft: ", p), err)
	}
	if err := oprot.WriteBool(ctx, bool(p.IsLeft)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.isLeft (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:isLeft: ", p), err)
	}
	return err
}

func (p *PartitionRef) Equals(other *PartitionRef) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.SplitId != other.SplitId {
		return false
	}
	if p.IsLeft != other.IsLeft {
		return false
	}
	return true
}

func (p *PartitionRef) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("PartitionRef(%+v)", *p)
}

type ServeOnMaster interface {
	// Parameters:
	//  - Record
	UpdateSplitInfo(ctx context.Context, record *SplitRecord) (_err error)
	Stop(ctx context.Context) (_err error)
}

type ServeOnMasterClient struct {
	c    thrift.TClient
	meta thrift.ResponseMeta
}

func NewServeOnMasterClientFactory(t thrift.TTransport, f thrift.TProtocolFactory) *ServeOnMasterClient {
	return &ServeOnMasterClient{
		c: thrift.NewTStandardClient(f.GetProtocol(t), f.GetProtocol(t)),
	}
}

func NewServeOnMasterClientProtocol(t thrift.TTransport, iprot thrift.TProtocol, oprot thrift.TProtocol) *ServeOnMasterClient {
	return &ServeOnMasterClient{
		c: thrift.NewTStandardClient(iprot, oprot),
	}
}

func NewServeOnMasterClient(c thrift.TClient) *ServeOnMasterClient {
	return &ServeOnMasterClient{
		c: c,
	}
}

func (p *ServeOnMasterClient) Client_() thrift.TClient {
	return p.c
}

func (p *ServeOnMasterClient) LastResponseMeta_() thrift.ResponseMeta {
	return p.meta
}

func (p *ServeOnMasterClient) SetLastResponseMeta_(meta thrift.ResponseMeta) {
	p.meta = meta
}

// Parameters:
//   - Record
func (p *ServeOnMasterClient) UpdateSplitInfo(ctx context.Context, record *SplitRecord) (_err error) {
	var _args18 ServeOnMasterUpdateSplitInfoArgs
	_args18.Record = record
	var _result20 ServeOnMasterUpdateSplitInfoResult
	var _meta19 thrift.ResponseMeta
	_meta19, _err = p.Client_().Call(ctx, "UpdateSplitInfo", &_args18, &_result20)
	p.SetLastResponseMeta_(_meta19)
	if _err != nil {
		return
	}
	return nil
}

func (p *ServeOnMasterClient) Stop(ctx context.Context) (_err error) {
	var _args21 ServeOnMasterStopArgs
	var _result23 ServeOnMasterStopResult
	var _meta22 thrift.ResponseMeta
	_meta22, _err = p.Client_().Call(ctx, "Stop", &_args21, &_result23)
	p.SetLastResponseMeta_(_meta22)
	if _err != nil {
		return
	}
	return nil
}

type ServeOnMasterProcessor struct {
	processorMap map[string]thrift.TProcessorFunction
	handler      ServeOnMaster
}

func (p *ServeOnMasterProcessor) AddToProcessorMap(key string, processor thrift.TProcessorFunction) {
	p.processorMap[key] = processor
}

func (p *ServeOnMasterProcessor) GetProcessorFunction(key string) (processor thrift.TProcessorFunction, ok bool) {
	processor, ok = p.processorMap[key]
	return processor, ok
}

func (p *ServeOnMasterProcessor) ProcessorMap() map[string]thrift.TProcessorFunction {
	return p.processorMap
}

func NewServeOnMasterProcessor(handler ServeOnMaster) *ServeOnMasterProcessor {

	self24 := &ServeOnMasterProcessor{handler: handler, processorMap: make(map[string]thrift.TProcessorFunction)}
	self24.processorMap["UpdateSplitInfo"] = &serveOnMasterProcessorUpdateSplitInfo{handler: handler}
	self24.processorMap["Stop"] = &serveOnMasterProcessorStop{handler: handler}
	return self24
}

func (p *ServeOnMasterProcessor) Process(ctx context.Context, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	name, _, seqId, err2 := iprot.ReadMessageBegin(ctx)
	if err2 != nil {
		return false, thrift.WrapTException(err2)
	}
	if processor, ok := p.GetProcessorFunction(name); ok {
		return processor.Process(ctx, seqId, iprot, oprot)
	}
	iprot.Skip(ctx, thrift.STRUCT)
	iprot.ReadMessageEnd(ctx)
	x25 := thrift.NewTApplicationException(thrift.UNKNOWN_METHOD, "Unknown function "+name)
	oprot.WriteMessageBegin(ctx, name, thrift.EXCEPTION, seqId)
	x25.Write(ctx, oprot)
	oprot.WriteMessageEnd(ctx)
	oprot.Flush(ctx)
	return false, x25

}

type serveOnMasterProcessorUpdateSplitInfo struct {
	handler ServeOnMaster
}

func (p *serveOnMasterProcessorUpdateSplitInfo) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err26 error
	args := ServeOnMasterUpdateSplitInfoArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "UpdateSplitInfo", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithCancel(ctx)
		defer cancel()
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel()
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := ServeOnMasterUpdateSplitInfoResult{}
	if err2 := p.handler.UpdateSplitInfo(ctx, args.Record); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		if errors.Is(err2, thrift.ErrAbandonRequest) {
			return false, thrift.WrapTException(err2)
		}
		_exc27 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing UpdateSplitInfo: "+err2.Error())
		if err2 := oprot.WriteMessageBegin(ctx, "UpdateSplitInfo", thrift.EXCEPTION, seqId); err2 != nil {
			_write_err26 = thrift.WrapTException(err2)
		}
		if err2 := _exc27.Write(ctx, oprot); _write_err26 == nil && err2 != nil {
			_write_err26 = thrift.WrapTException(err2)
		}
		if err2 := oprot.WriteMessageEnd(ctx); _write_err26 == nil && err2 != nil {
			_write_err26 = thrift.WrapTException(err2)
		}
		if err2 := oprot.Flush(ctx); _write_err26 == nil && err2 != nil {
			_write_err26 = thrift.WrapTException(err2)
		}
		if _write_err26 != nil {
			return false, thrift.WrapTException(_write_err26)
		}
		return true, err
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "UpdateSplitInfo", thrift.REPLY, seqId); err2 != nil {
		_write_err26 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err26 == nil && err2 != nil {
		_write_err26 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err26 == nil && err2 != nil {
		_write_err26 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err26 == nil && err2 != nil {
		_write_err26 = thrift.WrapTException(err2)
	}
	if _write_err26 != nil {
		return false, thrift.WrapTException(_write_err26)
	}
	return true, err
}

type serveOnMasterProcessorStop struct {
	handler ServeOnMaster
}

func (p *serveOnMasterProcessorStop) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err28 error
	args := ServeOnMasterStopArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "Stop", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithCancel(ctx)
		defer cancel()
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel()
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := ServeOnMasterStopResult{}
	if err2 := p.handler.Stop(ctx); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		if errors.Is(err2, thrift.ErrAbandonRequest) {
			return false, thrift.WrapTException(err2)
		}
		_exc29 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing Stop: "+err2.Error())
		if err2 := oprot.WriteMessageBegin(ctx, "Stop", thrift.EXCEPTION, seqId); err2 != nil {
			_write_err28 = thrift.WrapTException(err2)
		}
		if err2 := _exc29.Write(ctx, oprot); _write_err28 == nil && err2 != nil {
			_write_err28 = thrift.WrapTException(err2)
		}
		if err2 := oprot.WriteMessageEnd(ctx); _write_err28 == nil && err2 != nil {
			_write_err28 = thrift.WrapTException(err2)
		}
		if err2 := oprot.Flush(ctx); _write_err28 == nil && err2 != nil {
			_write_err28 = thrift.WrapTException(err2)
		}
		if _write_err28 != nil {
			return false, thrift.WrapTException(_write_err28)
		}
		return true, err
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "Stop", thrift.REPLY, seqId); err2 != nil {
		_write_err28 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err28 == nil && err2 != nil {
		_write_err28 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err28 == nil && err2 != nil {
		_write_err28 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err28 == nil && err2 != nil {
		_write_err28 = thrift.WrapTException(err2)
	}
	if _write_err28 != nil {
		return false, thrift.WrapTException(_write_err28)
	}
	return true, err
}

// HELPER FUNCTIONS AND STRUCTURES

// Attributes:
//   - Record
type ServeOnMasterUpdateSplitInfoArgs struct {
	Record *SplitRecord `thrift:"record,1" db:"record" json:"record"`
}

func NewServeOnMasterUpdateSplitInfoArgs() *ServeOnMasterUpdateSplitInfoArgs {
	return &ServeOnMasterUpdateSplitInfoArgs{}
}

var ServeOnMasterUpdateSplitInfoArgs_Record_DEFAULT *SplitRecord

func (p *ServeOnMasterUpdateSplitInfoArgs) GetRecord() *SplitRecord {
	if !p.IsSetRecord() {
		return ServeOnMasterUpdateSplitInfoArgs_Record_DEFAULT
	}
	return p.Record
}
func (p *ServeOnMasterUpdateSplitInfoArgs) IsSetRecord() bool {
	return p.Record != nil
}

func (p *ServeOnMasterUpdateSplitInfoArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ServeOnMasterUpdateSplitInfoArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Record = &SplitRecord{}
	if err := p.Record.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Record), err)
	}
	return nil
}

func (p *ServeOnMasterUpdateSplitInfoArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "UpdateSplitInfo_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ServeOnMasterUpdateSplitInfoArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "record", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:record: ", p), err)
	}
	if err := p.Record.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Record), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:record: ", p), err)
	}
	return err
}

func (p *ServeOnMasterUpdateSplitInfoArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ServeOnMasterUpdateSplitInfoArgs(%+v)", *p)
}

type ServeOnMasterUpdateSplitInfoResult struct {
}

func NewServeOnMasterUpdateSplitInfoResult() *ServeOnMasterUpdateSplitInfoResult {
	return &ServeOnMasterUpdateSplitInfoResult{}
}

func (p *ServeOnMasterUpdateSplitInfoResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.Skip(ctx, fieldTypeId); err != nil {
			return err
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ServeOnMasterUpdateSplitInfoResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "UpdateSplitInfo_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ServeOnMasterUpdateSplitInfoResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ServeOnMasterUpdateSplitInfoResult(%+v)", *p)
}

type ServeOnMasterStopArgs struct {
}

func NewServeOnMasterStopArgs() *ServeOnMasterStopArgs {
	return &ServeOnMasterStopArgs{}
}

func (p *ServeOnMasterStopArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.Skip(ctx, fieldTypeId); err != nil {
			return err
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ServeOnMasterStopArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "Stop_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ServeOnMasterStopArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ServeOnMasterStopArgs(%+v)", *p)
}

type ServeOnMasterStopResult struct {
}

func NewServeOnMasterStopResult() *ServeOnMasterStopResult {
	return &ServeOnMasterStopResult{}
}

func (p *ServeOnMasterStopResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.Skip(ctx, fieldTypeId); err != nil {
			return err
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ServeOnMasterStopResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "Stop_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ServeOnMasterStopResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ServeOnMasterStopResult(%+v)", *p)
}

type ServeOnWorker interface {
	DataInit(ctx context.Context) (_err error)
	// Parameters:
	//  - Partition
	CollectAttrBasicInfo(ctx context.Context, partition *PartitionRef) (_r map[int32]*AttrBasic, _err error)
	// Parameters:
	//  - Partition
	//  - RelatedFeatures
	CollectInsBasicInfo(ctx context.Context, partition *PartitionRef, relatedFeatures []int32) (_r *PartitionInsBasic, _err error)
	// Parameters:
	//  - NonNaNlabelWeights
	BeforeGenAVC(ctx context.Context, nonNaNlabelWeights map[int32]map[float64]float64) (_err error)
	AfterSplit(ctx context.Context) (_err error)
	// Parameters:
	//  - Partition
	//  - SmallAVCTasks
	//  - ConciseAVCTasks
	GenGeneralAVC(ctx context.Context, partition *PartitionRef, smallAVCTasks map[int32][]float64, conciseAVCTasks map[int32][]float64) (_err error)
	// Parameters:
	//  - Partition
	//  - FeatureId
	//  - Tasks
	GenPartialAVC(ctx context.Context, partition *PartitionRef, featureId int32, tasks []*Interval) (_r []*AVC, _err error)
	// Parameters:
	//  - Partition
	//  - NewPartitionId_
	//  - SplitAttr
	//  - SplitValue
	//  - HasNaN
	Split(ctx context.Context, partition *PartitionRef, newPartitionId int64, splitAttr int32, splitValue float64, hasNaN bool) (_err error)
	// Parameters:
	//  - Partition
	//  - Avc
	MergeGeneralAVC(ctx context.Context, partition *PartitionRef, avc *AVC) (_err error)
	Clear(ctx context.Context) (_err error)
	Stop(ctx context.Context) (_err error)
}

type ServeOnWorkerClient struct {
	c    thrift.TClient
	meta thrift.ResponseMeta
}

func NewServeOnWorkerClientFactory(t thrift.TTransport, f thrift.TProtocolFactory) *ServeOnWorkerClient {
	return &ServeOnWorkerClient{
		c: thrift.NewTStandardClient(f.GetProtocol(t), f.GetProtocol(t)),
	}
}

func NewServeOnWorkerClientProtocol(t thrift.TTransport, iprot thrift.TProtocol, oprot thrift.TProtocol) *ServeOnWorkerClient {
	return &ServeOnWorkerClient{
		c: thrift.NewTStandardClient(iprot, oprot),
	}
}

func NewServeOnWorkerClient(c thrift.TClient) *ServeOnWorkerClient {
	return &ServeOnWorkerClient{
		c: c,
	}
}

func (p *ServeOnWorkerClient) Client_() thrift.TClient {
	return p.c
}

func (p *ServeOnWorkerClient) LastResponseMeta_() thrift.ResponseMeta {
	return p.meta
}

func (p *ServeOnWorkerClient) SetLastResponseMeta_(meta thrift.ResponseMeta) {
	p.meta = meta
}

func (p *ServeOnWorkerClient) DataInit(ctx context.Context) (_err error) {
	var _args36 ServeOnWorkerDataInitArgs
	var _result38 ServeOnWorkerDataInitResult
	var _meta37 thrift.ResponseMeta
	_meta37, _err = p.Client_().Call(ctx, "DataInit", &_args36, &_result38)
	p.SetLastResponseMeta_(_meta37)
	if _err != nil {
		return
	}
	return nil
}

// Parameters:
//   - Partition
func (p *ServeOnWorkerClient) CollectAttrBasicInfo(ctx context.Context, partition *PartitionRef) (_r map[int32]*AttrBasic, _err error) {
	var _args39 ServeOnWorkerCollectAttrBasicInfoArgs
	_args39.Partition = partition
	var _result41 ServeOnWorkerCollectAttrBasicInfoResult
	var _meta40 thrift.ResponseMeta
	_meta40, _err = p.Client_().Call(ctx, "CollectAttrBasicInfo", &_args39, &_result41)
	p.SetLastResponseMeta_(_meta40)
	if _err != nil {
		return
	}
	return _result41.GetSuccess(), nil
}

// Parameters:
//   - Partition
//   - RelatedFeatures
func (p *ServeOnWorkerClient) CollectInsBasicInfo(ctx context.Context, partition *PartitionRef, relatedFeatures []int32) (_r *PartitionInsBasic, _err error) {
	var _args42 ServeOnWorkerCollectInsBasicInfoArgs
	_args42.Partition = partition
	_args42.RelatedFeatures = relatedFeatures
	var _result44 ServeOnWorkerCollectInsBasicInfoResult
	var _meta43 thrift.ResponseMeta
	_meta43, _err = p.Client_().Call(ctx, "CollectInsBasicInfo", &_args42, &_result44)
	p.SetLastResponseMeta_(_meta43)
	if _err != nil {
		return
	}
	if _ret45 := _result44.GetSuccess(); _ret45 != nil {
		return _ret45, nil
	}
	return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "CollectInsBasicInfo failed: unknown result")
}

// Parameters:
//   - NonNaNlabelWeights
func (p *ServeOnWorkerClient) BeforeGenAVC(ctx context.Context, nonNaNlabelWeights map[int32]map[float64]float64) (_err error) {
	var _args46 ServeOnWorkerBeforeGenAVCArgs
	_args46.NonNaNlabelWeights = nonNaNlabelWeights
	var _result48 ServeOnWorkerBeforeGenAVCResult
	var _meta47 thrift.ResponseMeta
	_meta47, _err = p.Client_().Call(ctx, "BeforeGenAVC", &_args46, &_result48)
	p.SetLastResponseMeta_(_meta47)
	if _err != nil {
		return
	}
	return nil
}

func (p *ServeOnWorkerClient) AfterSplit(ctx context.Context) (_err error) {
	var _args49 ServeOnWorkerAfterSplitArgs
	var _result51 ServeOnWorkerAfterSplitResult
	var _meta50 thrift.ResponseMeta
	_meta50, _err = p.Client_().Call(ctx, "AfterSplit", &_args49, &_result51)
	p.SetLastResponseMeta_(_meta50)
	if _err != nil {
		return
	}
	return nil
}

// Parameters:
//   - Partition
//   - SmallAVCTasks
//   - ConciseAVCTasks
func (p *ServeOnWorkerClient) GenGeneralAVC(ctx context.Context, partition *PartitionRef, smallAVCTasks map[int32][]float64, conciseAVCTasks map[int32][]float64) (_err error) {
	var _args52 ServeOnWorkerGenGeneralAVCArgs
	_args52.Partition = partition
	_args52.SmallAVCTasks = smallAVCTasks
	_args52.ConciseAVCTasks = conciseAVCTasks
	var _result54 ServeOnWorkerGenGeneralAVCResult
	var _meta53 thrift.ResponseMeta
	_meta53, _err = p.Client_().Call(ctx, "GenGeneralAVC", &_args52, &_result54)
	p.SetLastResponseMeta_(_meta53)
	if _err != nil {
		return
	}
	return nil
}

// Parameters:
//   - Partition
//   - FeatureId
//   - Tasks
func (p *ServeOnWorkerClient) GenPartialAVC(ctx context.Context, partition *PartitionRef, featureId int32, tasks []*Interval) (_r []*AVC, _err error) {
	var _args55 ServeOnWorkerGenPartialAVCArgs
	_args55.Partition = partition
	_args55.FeatureId = featureId
	_args55.Tasks = tasks
	var _result57 ServeOnWorkerGenPartialAVCResult
	var _meta56 thrift.ResponseMeta
	_meta56, _err = p.Client_().Call(ctx, "GenPartialAVC", &_args55, &_result57)
	p.SetLastResponseMeta_(_meta56)
	if _err != nil {
		return
	}
	return _result57.GetSuccess(), nil
}

// Parameters:
//   - Partition
//   - NewPartitionId_
//   - SplitAttr
//   - SplitValue
//   - HasNaN
func (p *ServeOnWorkerClient) Split(ctx context.Context, partition *PartitionRef, newPartitionId int64, splitAttr int32, splitValue float64, hasNaN bool) (_err error) {
	var _args58 ServeOnWorkerSplitArgs
	_args58.Partition = partition
	_args58.NewPartitionId_ = newPartitionId
	_args58.SplitAttr = splitAttr
	_args58.SplitValue = splitValue
	_args58.HasNaN = hasNaN
	var _result60 ServeOnWorkerSplitResult
	var _meta59 thrift.ResponseMeta
	_meta59, _err = p.Client_().Call(ctx, "Split", &_args58, &_result60)
	p.SetLastResponseMeta_(_meta59)
	if _err != nil {
		return
	}
	return nil
}

// Parameters:
//   - Partition
//   - Avc
func (p *ServeOnWorkerClient) MergeGeneralAVC(ctx context.Context, partition *PartitionRef, avc *AVC) (_err error) {
	var _args61 ServeOnWorkerMergeGeneralAVCArgs
	_args61.Partition = partition
	_args61.Avc = avc
	var _result63 ServeOnWorkerMergeGeneralAVCResult
	var _meta62 thrift.ResponseMeta
	_meta62, _err = p.Client_().Call(ctx, "MergeGeneralAVC", &_args61, &_result63)
	p.SetLastResponseMeta_(_meta62)
	if _err != nil {
		return
	}
	return nil
}

func (p *ServeOnWorkerClient) Clear(ctx context.Context) (_err error) {
	var _args64 ServeOnWorkerClearArgs
	var _result66 ServeOnWorkerClearResult
	var _meta65 thrift.ResponseMeta
	_meta65, _err = p.Client_().Call(ctx, "Clear", &_args64, &_result66)
	p.SetLastResponseMeta_(_meta65)
	if _err != nil {
		return
	}
	return nil
}

func (p *ServeOnWorkerClient) Stop(ctx context.Context) (_err error) {
	var _args67 ServeOnWorkerStopArgs
	var _result69 ServeOnWorkerStopResult
	var _meta68 thrift.ResponseMeta
	_meta68, _err = p.Client_().Call(ctx, "Stop", &_args67, &_result69)
	p.SetLastResponseMeta_(_meta68)
	if _err != nil {
		return
	}
	return nil
}

type ServeOnWorkerProcessor struct {
	processorMap map[string]thrift.TProcessorFunction
	handler      ServeOnWorker
}

func (p *ServeOnWorkerProcessor) AddToProcessorMap(key string, processor thrift.TProcessorFunction) {
	p.processorMap[key] = processor
}

func (p *ServeOnWorkerProcessor) GetProcessorFunction(key string) (processor thrift.TProcessorFunction, ok bool) {
	processor, ok = p.processorMap[key]
	return processor, ok
}

func (p *ServeOnWorkerProcessor) ProcessorMap() map[string]thrift.TProcessorFunction {
	return p.processorMap
}

func NewServeOnWorkerProcessor(handler ServeOnWorker) *ServeOnWorkerProcessor {

	self70 := &ServeOnWorkerProcessor{handler: handler, processorMap: make(map[string]thrift.TProcessorFunction)}
	self70.processorMap["DataInit"] = &serveOnWorkerProcessorDataInit{handler: handler}
	self70.processorMap["CollectAttrBasicInfo"] = &serveOnWorkerProcessorCollectAttrBasicInfo{handler: handler}
	self70.processorMap["CollectInsBasicInfo"] = &serveOnWorkerProcessorCollectInsBasicInfo{handler: handler}
	self70.processorMap["BeforeGenAVC"] = &serveOnWorkerProcessorBeforeGenAVC{handler: handler}
	self70.processorMap["AfterSplit"] = &serveOnWorkerProcessorAfterSplit{handler: handler}
	self70.processorMap["GenGeneralAVC"] = &serveOnWorkerProcessorGenGeneralAVC{handler: handler}
	self70.processorMap["GenPartialAVC"] = &serveOnWorkerProcessorGenPartialAVC{handler: handler}
	self70.processorMap["Split"] = &serveOnWorkerProcessorSplit{handler: handler}
	self70.processorMap["MergeGeneralAVC"] = &serveOnWorkerProcessorMergeGeneralAVC{handler: handler}
	self70.processorMap["Clear"] = &serveOnWorkerProcessorClear{handler: handler}
	self70.processorMap["Stop"] = &serveOnWorkerProcessorStop{handler: handler}
	return self70
}

func (p *ServeOnWorkerProcessor) Process(ctx context.Context, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	name, _, seqId, err2 := iprot.ReadMessageBegin(ctx)
	if err2 != nil {
		return false, thrift.WrapTException(err2)
	}
	if processor, ok := p.GetProcessorFunction(name); ok {
		return processor.Process(ctx, seqId, iprot, oprot)
	}
	iprot.Skip(ctx, thrift.STRUCT)
	iprot.ReadMessageEnd(ctx)
	x71 := thrift.NewTApplicationException(thrift.UNKNOWN_METHOD, "Unknown function "+name)
	oprot.WriteMessageBegin(ctx, name, thrift.EXCEPTION, seqId)
	x71.Write(ctx, oprot)
	oprot.WriteMessageEnd(ctx)
	oprot.Flush(ctx)
	return false, x71

}

type serveOnWorkerProcessorDataInit struct {
	handler ServeOnWorker
}

func (p *serveOnWorkerProcessorDataInit) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err72 error
	args := ServeOnWorkerDataInitArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "DataInit", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithCancel(ctx)
		defer cancel()
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel()
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := ServeOnWorkerDataInitResult{}
	if err2 := p.handler.DataInit(ctx); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		if errors.Is(err2, thrift.ErrAbandonRequest) {
			return false, thrift.WrapTException(err2)
		}
		_exc73 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing DataInit: "+err2.Error())
		if err2 := oprot.WriteMessageBegin(ctx, "DataInit", thrift.EXCEPTION, seqId); err2 != nil {
			_write_err72 = thrift.WrapTException(err2)
		}
		if err2 := _exc73.Write(ctx, oprot); _write_err72 == nil && err2 != nil {
			_write_err72 = thrift.WrapTException(err2)
		}
		if err2 := oprot.WriteMessageEnd(ctx); _write_err72 == nil && err2 != nil {
			_write_err72 = thrift.WrapTException(err2)
		}
		if err2 := oprot.Flush(ctx); _write_err72 == nil && err2 != nil {
			_write_err72 = thrift.WrapTException(err2)
		}
		if _write_err72 != nil {
			return false, thrift.WrapTException(_write_err72)
		}
		return true, err
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "DataInit", thrift.REPLY, seqId); err2 != nil {
		_write_err72 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err72 == nil && err2 != nil {
		_write_err72 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err72 == nil && err2 != nil {
		_write_err72 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err72 == nil && err2 != nil {
		_write_err72 = thrift.WrapTException(err2)
	}
	if _write_err72 != nil {
		return false, thrift.WrapTException(_write_err72)
	}
	return true, err
}

type serveOnWorkerProcessorCollectAttrBasicInfo struct {
	handler ServeOnWorker
}

func (p *serveOnWorkerProcessorCollectAttrBasicInfo) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err74 error
	args := ServeOnWorkerCollectAttrBasicInfoArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "CollectAttrBasicInfo", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithCancel(ctx)
		defer cancel()
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel()
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := ServeOnWorkerCollectAttrBasicInfoResult{}
	if retval, err2 := p.handler.CollectAttrBasicInfo(ctx, args.Partition); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		if errors.Is(err2, thrift.ErrAbandonRequest) {
			return false, thrift.WrapTException(err2)
		}
		_exc75 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing CollectAttrBasicInfo: "+err2.Error())
		if err2 := oprot.WriteMessageBegin(ctx, "CollectAttrBasicInfo", thrift.EXCEPTION, seqId); err2 != nil {
			_write_err74 = thrift.WrapTException(err2)
		}
		if err2 := _exc75.Write(ctx, oprot); _write_err74 == nil && err2 != nil {
			_write_err74 = thrift.WrapTException(err2)
		}
		if err2 := oprot.WriteMessageEnd(ctx); _write_err74 == nil && err2 != nil {
			_write_err74 = thrift.WrapTException(err2)
		}
		if err2 := oprot.Flush(ctx); _write_err74 == nil && err2 != nil {
			_write_err74 = thrift.WrapTException(err2)
		}
		if _write_err74 != nil {
			return false, thrift.WrapTException(_write_err74)
		}
		return true, err
	} else {
		result.Success = retval
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "CollectAttrBasicInfo", thrift.REPLY, seqId); err2 != nil {
		_write_err74 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err74 == nil && err2 != nil {
		_write_err74 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err74 == nil && err2 != nil {
		_write_err74 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err74 == nil && err2 != nil {
		_write_err74 = thrift.WrapTException(err2)
	}
	if _write_err74 != nil {
		return false, thrift.WrapTException(_write_err74)
	}
	return true, err
}

type serveOnWorkerProcessorCollectInsBasicInfo struct {
	handler ServeOnWorker
}

func (p *serveOnWorkerProcessorCollectInsBasicInfo) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err76 error
	args := ServeOnWorkerCollectInsBasicInfoArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "CollectInsBasicInfo", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithCancel(ctx)
		defer cancel()
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel()
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := ServeOnWorkerCollectInsBasicInfoResult{}
	if retval, err2 := p.handler.CollectInsBasicInfo(ctx, args.Partition, args.RelatedFeatures); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		if errors.Is(err2, thrift.ErrAbandonRequest) {
			return false, thrift.WrapTException(err2)
		}
		_exc77 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing CollectInsBasicInfo: "+err2.Error())
		if err2 := oprot.WriteMessageBegin(ctx, "CollectInsBasicInfo", thrift.EXCEPTION, seqId); err2 != nil {
			_write_err76 = thrift.WrapTException(err2)
		}
		if err2 := _exc77.Write(ctx, oprot); _write_err76 == nil && err2 != nil {
			_write_err76 = thrift.WrapTException(err2)
		}
		if err2 := oprot.WriteMessageEnd(ctx); _write_err76 == nil && err2 != nil {
			_write_err76 = thrift.WrapTException(err2)
		}
		if err2 := oprot.Flush(ctx); _write_err76 == nil && err2 != nil {
			_write_err76 = thrift.WrapTException(err2)
		}
		if _write_err76 != nil {
			return false, thrift.WrapTException(_write_err76)
		}
		return true, err
	} else {
		result.Success = retval
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "CollectInsBasicInfo", thrift.REPLY, seqId); err2 != nil {
		_write_err76 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err76 == nil && err2 != nil {
		_write_err76 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err76 == nil && err2 != nil {
		_write_err76 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err76 == nil && err2 != nil {
		_write_err76 = thrift.WrapTException(err2)
	}
	if _write_err76 != nil {
		return false, thrift.WrapTException(_write_err76)
	}
	return true, err
}

type serveOnWorkerProcessorBeforeGenAVC struct {
	handler ServeOnWorker
}

func (p *serveOnWorkerProcessorBeforeGenAVC) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err78 error
	args := ServeOnWorkerBeforeGenAVCArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "BeforeGenAVC", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithCancel(ctx)
		defer cancel()
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel()
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := ServeOnWorkerBeforeGenAVCResult{}
	if err2 := p.handler.BeforeGenAVC(ctx, args.NonNaNlabelWeights); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		if errors.Is(err2, thrift.ErrAbandonRequest) {
			return false, thrift.WrapTException(err2)
		}
		_exc79 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing BeforeGenAVC: "+err2.Error())
		if err2 := oprot.WriteMessageBegin(ctx, "BeforeGenAVC", thrift.EXCEPTION, seqId); err2 != nil {
			_write_err78 = thrift.WrapTException(err2)
		}
		if err2 := _exc79.Write(ctx, oprot); _write_err78 == nil && err2 != nil {
			_write_err78 = thrift.WrapTException(err2)
		}
		if err2 := oprot.WriteMessageEnd(ctx); _write_err78 == nil && err2 != nil {
			_write_err78 = thrift.WrapTException(err2)
		}
		if err2 := oprot.Flush(ctx); _write_err78 == nil && err2 != nil {
			_write_err78 = thrift.WrapTException(err2)
		}
		if _write_err78 != nil {
			return false, thrift.WrapTException(_write_err78)
		}
		return true, err
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "BeforeGenAVC", thrift.REPLY, seqId); err2 != nil {
		_write_err78 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err78 == nil && err2 != nil {
		_write_err78 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err78 == nil && err2 != nil {
		_write_err78 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err78 == nil && err2 != nil {
		_write_err78 = thrift.WrapTException(err2)
	}
	if _write_err78 != nil {
		return false, thrift.WrapTException(_write_err78)
	}
	return true, err
}

type serveOnWorkerProcessorAfterSplit struct {
	handler ServeOnWorker
}

func (p *serveOnWorkerProcessorAfterSplit) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err80 error
	args := ServeOnWorkerAfterSplitArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "AfterSplit", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithCancel(ctx)
		defer cancel()
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel()
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := ServeOnWorkerAfterSplitResult{}
	if err2 := p.handler.AfterSplit(ctx); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		if errors.Is(err2, thrift.ErrAbandonRequest) {
			return false, thrift.WrapTException(err2)
		}
		_exc81 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing AfterSplit: "+err2.Error())
		if err2 := oprot.WriteMessageBegin(ctx, "AfterSplit", thrift.EXCEPTION, seqId); err2 != nil {
			_write_err80 = thrift.WrapTException(err2)
		}
		if err2 := _exc81.Write(ctx, oprot); _write_err80 == nil && err2 != nil {
			_write_err80 = thrift.WrapTException(err2)
		}
		if err2 := oprot.WriteMessageEnd(ctx); _write_err80 == nil && err2 != nil {
			_write_err80 = thrift.WrapTException(err2)
		}
		if err2 := oprot.Flush(ctx); _write_err80 == nil && err2 != nil {
			_write_err80 = thrift.WrapTException(err2)
		}
		if _write_err80 != nil {
			return false, thrift.WrapTException(_write_err80)
		}
		return true, err
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "AfterSplit", thrift.REPLY, seqId); err2 != nil {
		_write_err80 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err80 == nil && err2 != nil {
		_write_err80 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err80 == nil && err2 != nil {
		_write_err80 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err80 == nil && err2 != nil {
		_write_err80 = thrift.WrapTException(err2)
	}
	if _write_err80 != nil {
		return false, thrift.WrapTException(_write_err80)
	}
	return true, err
}

type serveOnWorkerProcessorGenGeneralAVC struct {
	handler ServeOnWorker
}

func (p *serveOnWorkerProcessorGenGeneralAVC) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err82 error
	args := ServeOnWorkerGenGeneralAVCArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "GenGeneralAVC", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithCancel(ctx)
		defer cancel()
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel()
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := ServeOnWorkerGenGeneralAVCResult{}
	if err2 := p.handler.GenGeneralAVC(ctx, args.Partition, args.SmallAVCTasks, args.ConciseAVCTasks); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		if errors.Is(err2, thrift.ErrAbandonRequest) {
			return false, thrift.WrapTException(err2)
		}
		_exc83 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing GenGeneralAVC: "+err2.Error())
		if err2 := oprot.WriteMessageBegin(ctx, "GenGeneralAVC", thrift.EXCEPTION, seqId); err2 != nil {
			_write_err82 = thrift.WrapTException(err2)
		}
		if err2 := _exc83.Write(ctx, oprot); _write_err82 == nil && err2 != nil {
			_write_err82 = thrift.WrapTException(err2)
		}
		if err2 := oprot.WriteMessageEnd(ctx); _write_err82 == nil && err2 != nil {
			_write_err82 = thrift.WrapTException(err2)
		}
		if err2 := oprot.Flush(ctx); _write_err82 == nil && err2 != nil {
			_write_err82 = thrift.WrapTException(err2)
		}
		if _write_err82 != nil {
			return false, thrift.WrapTException(_write_err82)
		}
		return true, err
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "GenGeneralAVC", thrift.REPLY, seqId); err2 != nil {
		_write_err82 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err82 == nil && err2 != nil {
		_write_err82 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err82 == nil && err2 != nil {
		_write_err82 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err82 == nil && err2 != nil {
		_write_err82 = thrift.WrapTException(err2)
	}
	if _write_err82 != nil {
		return false, thrift.WrapTException(_write_err82)
	}
	return true, err
}

type serveOnWorkerProcessorGenPartialAVC struct {
	handler ServeOnWorker
}

func (p *serveOnWorkerProcessorGenPartialAVC) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err84 error
	args := ServeOnWorkerGenPartialAVCArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "GenPartialAVC", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithCancel(ctx)
		defer cancel()
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel()
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := ServeOnWorkerGenPartialAVCResult{}
	if retval, err2 := p.handler.GenPartialAVC(ctx, args.Partition, args.FeatureId, args.Tasks); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		if errors.Is(err2, thrift.ErrAbandonRequest) {
			return false, thrift.WrapTException(err2)
		}
		_exc85 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing GenPartialAVC: "+err2.Error())
		if err2 := oprot.WriteMessageBegin(ctx, "GenPartialAVC", thrift.EXCEPTION, seqId); err2 != nil {
			_write_err84 = thrift.WrapTException(err2)
		}
		if err2 := _exc85.Write(ctx, oprot); _write_err84 == nil && err2 != nil {
			_write_err84 = thrift.WrapTException(err2)
		}
		if err2 := oprot.WriteMessageEnd(ctx); _write_err84 == nil && err2 != nil {
			_write_err84 = thrift.WrapTException(err2)
		}
		if err2 := oprot.Flush(ctx); _write_err84 == nil && err2 != nil {
			_write_err84 = thrift.WrapTException(err2)
		}
		if _write_err84 != nil {
			return false, thrift.WrapTException(_write_err84)
		}
		return true, err
	} else {
		result.Success = retval
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "GenPartialAVC", thrift.REPLY, seqId); err2 != nil {
		_write_err84 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err84 == nil && err2 != nil {
		_write_err84 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err84 == nil && err2 != nil {
		_write_err84 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err84 == nil && err2 != nil {
		_write_err84 = thrift.WrapTException(err2)
	}
	if _write_err84 != nil {
		return false, thrift.WrapTException(_write_err84)
	}
	return true, err
}

type serveOnWorkerProcessorSplit struct {
	handler ServeOnWorker
}

func (p *serveOnWorkerProcessorSplit) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err86 error
	args := ServeOnWorkerSplitArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "Split", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithCancel(ctx)
		defer cancel()
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel()
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := ServeOnWorkerSplitResult{}
	if err2 := p.handler.Split(ctx, args.Partition, args.NewPartitionId_, args.SplitAttr, args.SplitValue, args.HasNaN); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		if errors.Is(err2, thrift.ErrAbandonRequest) {
			return false, thrift.WrapTException(err2)
		}
		_exc87 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing Split: "+err2.Error())
		if err2 := oprot.WriteMessageBegin(ctx, "Split", thrift.EXCEPTION, seqId); err2 != nil {
			_write_err86 = thrift.WrapTException(err2)
		}
		if err2 := _exc87.Write(ctx, oprot); _write_err86 == nil && err2 != nil {
			_write_err86 = thrift.WrapTException(err2)
		}
		if err2 := oprot.WriteMessageEnd(ctx); _write_err86 == nil && err2 != nil {
			_write_err86 = thrift.WrapTException(err2)
		}
		if err2 := oprot.Flush(ctx); _write_err86 == nil && err2 != nil {
			_write_err86 = thrift.WrapTException(err2)
		}
		if _write_err86 != nil {
			return false, thrift.WrapTException(_write_err86)
		}
		return true, err
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "Split", thrift.REPLY, seqId); err2 != nil {
		_write_err86 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err86 == nil && err2 != nil {
		_write_err86 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err86 == nil && err2 != nil {
		_write_err86 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err86 == nil && err2 != nil {
		_write_err86 = thrift.WrapTException(err2)
	}
	if _write_err86 != nil {
		return false, thrift.WrapTException(_write_err86)
	}
	return true, err
}

type serveOnWorkerProcessorMergeGeneralAVC struct {
	handler ServeOnWorker
}

func (p *serveOnWorkerProcessorMergeGeneralAVC) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err88 error
	args := ServeOnWorkerMergeGeneralAVCArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "MergeGeneralAVC", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithCancel(ctx)
		defer cancel()
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel()
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := ServeOnWorkerMergeGeneralAVCResult{}
	if err2 := p.handler.MergeGeneralAVC(ctx, args.Partition, args.Avc); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		if errors.Is(err2, thrift.ErrAbandonRequest) {
			return false, thrift.WrapTException(err2)
		}
		_exc89 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing MergeGeneralAVC: "+err2.Error())
		if err2 := oprot.WriteMessageBegin(ctx, "MergeGeneralAVC", thrift.EXCEPTION, seqId); err2 != nil {
			_write_err88 = thrift.WrapTException(err2)
		}
		if err2 := _exc89.Write(ctx, oprot); _write_err88 == nil && err2 != nil {
			_write_err88 = thrift.WrapTException(err2)
		}
		if err2 := oprot.WriteMessageEnd(ctx); _write_err88 == nil && err2 != nil {
			_write_err88 = thrift.WrapTException(err2)
		}
		if err2 := oprot.Flush(ctx); _write_err88 == nil && err2 != nil {
			_write_err88 = thrift.WrapTException(err2)
		}
		if _write_err88 != nil {
			return false, thrift.WrapTException(_write_err88)
		}
		return true, err
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "MergeGeneralAVC", thrift.REPLY, seqId); err2 != nil {
		_write_err88 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err88 == nil && err2 != nil {
		_write_err88 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err88 == nil && err2 != nil {
		_write_err88 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err88 == nil && err2 != nil {
		_write_err88 = thrift.WrapTException(err2)
	}
	if _write_err88 != nil {
		return false, thrift.WrapTException(_write_err88)
	}
	return true, err
}

type serveOnWorkerProcessorClear struct {
	handler ServeOnWorker
}

func (p *serveOnWorkerProcessorClear) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err90 error
	args := ServeOnWorkerClearArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "Clear", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithCancel(ctx)
		defer cancel()
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel()
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := ServeOnWorkerClearResult{}
	if err2 := p.handler.Clear(ctx); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		if errors.Is(err2, thrift.ErrAbandonRequest) {
			return false, thrift.WrapTException(err2)
		}
		_exc91 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing Clear: "+err2.Error())
		if err2 := oprot.WriteMessageBegin(ctx, "Clear", thrift.EXCEPTION, seqId); err2 != nil {
			_write_err90 = thrift.WrapTException(err2)
		}
		if err2 := _exc91.Write(ctx, oprot); _write_err90 == nil && err2 != nil {
			_write_err90 = thrift.WrapTException(err2)
		}
		if err2 := oprot.WriteMessageEnd(ctx); _write_err90 == nil && err2 != nil {
			_write_err90 = thrift.WrapTException(err2)
		}
		if err2 := oprot.Flush(ctx); _write_err90 == nil && err2 != nil {
			_write_err90 = thrift.WrapTException(err2)
		}
		if _write_err90 != nil {
			return false, thrift.WrapTException(_write_err90)
		}
		return true, err
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "Clear", thrift.REPLY, seqId); err2 != nil {
		_write_err90 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err90 == nil && err2 != nil {
		_write_err90 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err90 == nil && err2 != nil {
		_write_err90 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err90 == nil && err2 != nil {
		_write_err90 = thrift.WrapTException(err2)
	}
	if _write_err90 != nil {
		return false, thrift.WrapTException(_write_err90)
	}
	return true, err
}

type serveOnWorkerProcessorStop struct {
	handler ServeOnWorker
}

func (p *serveOnWorkerProcessorStop) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err92 error
	args := ServeOnWorkerStopArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "Stop", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelFunc
		ctx, cancel = context.WithCancel(ctx)
		defer cancel()
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel()
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := ServeOnWorkerStopResult{}
	if err2 := p.handler.Stop(ctx); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		if errors.Is(err2, thrift.ErrAbandonRequest) {
			return false, thrift.WrapTException(err2)
		}
		_exc93 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing Stop: "+err2.Error())
		if err2 := oprot.WriteMessageBegin(ctx, "Stop", thrift.EXCEPTION, seqId); err2 != nil {
			_write_err92 = thrift.WrapTException(err2)
		}
		if err2 := _exc93.Write(ctx, oprot); _write_err92 == nil && err2 != nil {
			_write_err92 = thrift.WrapTException(err2)
		}
		if err2 := oprot.WriteMessageEnd(ctx); _write_err92 == nil && err2 != nil {
			_write_err92 = thrift.WrapTException(err2)
		}
		if err2 := oprot.Flush(ctx); _write_err92 == nil && err2 != nil {
			_write_err92 = thrift.WrapTException(err2)
		}
		if _write_err92 != nil {
			return false, thrift.WrapTException(_write_err92)
		}
		return true, err
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "Stop", thrift.REPLY, seqId); err2 != nil {
		_write_err92 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err92 == nil && err2 != nil {
		_write_err92 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err92 == nil && err2 != nil {
		_write_err92 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err92 == nil && err2 != nil {
		_write_err92 = thrift.WrapTException(err2)
	}
	if _write_err92 != nil {
		return false, thrift.WrapTException(_write_err92)
	}
	return true, err
}

// HELPER FUNCTIONS AND STRUCTURES

type ServeOnWorkerDataInitArgs struct {
}

func NewServeOnWorkerDataInitArgs() *ServeOnWorkerDataInitArgs {
	return &ServeOnWorkerDataInitArgs{}
}

func (p *ServeOnWorkerDataInitArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.Skip(ctx, fieldTypeId); err != nil {
			return err
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ServeOnWorkerDataInitArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "DataInit_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ServeOnWorkerDataInitArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ServeOnWorkerDataInitArgs(%+v)", *p)
}

type ServeOnWorkerDataInitResult struct {
}

func NewServeOnWorkerDataInitResult() *ServeOnWorkerDataInitResult {
	return &ServeOnWorkerDataInitResult{}
}

func (p *ServeOnWorkerDataInitResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.Skip(ctx, fieldTypeId); err != nil {
			return err
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ServeOnWorkerDataInitResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "DataInit_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ServeOnWorkerDataInitResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ServeOnWorkerDataInitResult(%+v)", *p)
}

// Attributes:
//   - Partition
type ServeOnWorkerCollectAttrBasicInfoArgs struct {
	Partition *PartitionRef `thrift:"partition,1" db:"partition" json:"partition"`
}

func NewServeOnWorkerCollectAttrBasicInfoArgs() *ServeOnWorkerCollectAttrBasicInfoArgs {
	return &ServeOnWorkerCollectAttrBasicInfoArgs{}
}

var ServeOnWorkerCollectAttrBasicInfoArgs_Partition_DEFAULT *PartitionRef

func (p *ServeOnWorkerCollectAttrBasicInfoArgs) GetPartition() *PartitionRef {
	if !p.IsSetPartition() {
		return ServeOnWorkerCollectAttrBasicInfoArgs_Partition_DEFAULT
	}
	return p.Partition
}
func (p *ServeOnWorkerCollectAttrBasicInfoArgs) IsSetPartition() bool {
	return p.Partition != nil
}

func (p *ServeOnWorkerCollectAttrBasicInfoArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ServeOnWorkerCollectAttrBasicInfoArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Partition = &PartitionRef{}
	if err := p.Partition.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Partition), err)
	}
	return nil
}

func (p *ServeOnWorkerCollectAttrBasicInfoArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "CollectAttrBasicInfo_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ServeOnWorkerCollectAttrBasicInfoArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "partition", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:partition: ", p), err)
	}
	if err := p.Partition.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Partition), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:partition: ", p), err)
	}
	return err
}

func (p *ServeOnWorkerCollectAttrBasicInfoArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ServeOnWorkerCollectAttrBasicInfoArgs(%+v)", *p)
}

// Attributes:
//   - Success
type ServeOnWorkerCollectAttrBasicInfoResult struct {
	Success map[int32]*AttrBasic `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewServeOnWorkerCollectAttrBasicInfoResult() *ServeOnWorkerCollectAttrBasicInfoResult {
	return &ServeOnWorkerCollectAttrBasicInfoResult{}
}

var ServeOnWorkerCollectAttrBasicInfoResult_Success_DEFAULT map[int32]*AttrBasic

func (p *ServeOnWorkerCollectAttrBasicInfoResult) GetSuccess() map[int32]*AttrBasic {
	return p.Success
}
func (p *ServeOnWorkerCollectAttrBasicInfoResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ServeOnWorkerCollectAttrBasicInfoResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.MAP {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ServeOnWorkerCollectAttrBasicInfoResult) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading map begin: ", err)
	}
	tMap := make(map[int32]*AttrBasic, size)
	p.Success = tMap
	for i := 0; i < size; i++ {
		var _key94 int32
		if v, err := iprot.ReadI32(ctx); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_key94 = v
		}
		_val95 := &AttrBasic{}
		if err := _val95.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _val95), err)
		}
		p.Success[_key94] = _val95
	}
	if err := iprot.ReadMapEnd(ctx); err != nil {
		return thrift.PrependError("error reading map end: ", err)
	}
	return nil
}

func (p *ServeOnWorkerCollectAttrBasicInfoResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "CollectAttrBasicInfo_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ServeOnWorkerCollectAttrBasicInfoResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.MAP, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteMapBegin(ctx, thrift.I32, thrift.STRUCT, len(p.Success)); err != nil {
			return thrift.PrependError("error writing map begin: ", err)
		}
		for k, v := range p.Success {
			if err := oprot.WriteI32(ctx, int32(k)); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
			}
			if err := v.Write(ctx, oprot); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
			}
		}
		if err := oprot.WriteMapEnd(ctx); err != nil {
			return thrift.PrependError("error writing map end: ", err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *ServeOnWorkerCollectAttrBasicInfoResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ServeOnWorkerCollectAttrBasicInfoResult(%+v)", *p)
}

// Attributes:
//   - Partition
//   - RelatedFeatures
type ServeOnWorkerCollectInsBasicInfoArgs struct {
	Partition       *PartitionRef `thrift:"partition,1" db:"partition" json:"partition"`
	RelatedFeatures []int32       `thrift:"relatedFeatures,2" db:"relatedFeatures" json:"relatedFeatures"`
}

func NewServeOnWorkerCollectInsBasicInfoArgs() *ServeOnWorkerCollectInsBasicInfoArgs {
	return &ServeOnWorkerCollectInsBasicInfoArgs{}
}

var ServeOnWorkerCollectInsBasicInfoArgs_Partition_DEFAULT *PartitionRef

func (p *ServeOnWorkerCollectInsBasicInfoArgs) GetPartition() *PartitionRef {
	if !p.IsSetPartition() {
		return ServeOnWorkerCollectInsBasicInfoArgs_Partition_DEFAULT
	}
	return p.Partition
}

func (p *ServeOnWorkerCollectInsBasicInfoArgs) GetRelatedFeatures() []int32 {
	return p.RelatedFeatures
}
func (p *ServeOnWorkerCollectInsBasicInfoArgs) IsSetPartition() bool {
	return p.Partition != nil
}

func (p *ServeOnWorkerCollectInsBasicInfoArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ServeOnWorkerCollectInsBasicInfoArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Partition = &PartitionRef{}
	if err := p.Partition.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Partition), err)
	}
	return nil
}

func (p *ServeOnWorkerCollectInsBasicInfoArgs) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]int32, 0, size)
	p.RelatedFeatures = tSlice
	for i := 0; i < size; i++ {
		var _elem96 int32
		if v, err := iprot.ReadI32(ctx); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_elem96 = v
		}
		p.RelatedFeatures = append(p.RelatedFeatures, _elem96)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *ServeOnWorkerCollectInsBasicInfoArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "CollectInsBasicInfo_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ServeOnWorkerCollectInsBasicInfoArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "partition", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:partition: ", p), err)
	}
	if err := p.Partition.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Partition), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:partition: ", p), err)
	}
	return err
}

func (p *ServeOnWorkerCollectInsBasicInfoArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "relatedFeatures", thrift.LIST, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:relatedFeatures: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.I32, len(p.RelatedFeatures)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.RelatedFeatures {
		if err := oprot.WriteI32(ctx, int32(v)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:relatedFeatures: ", p), err)
	}
	return err
}

func (p *ServeOnWorkerCollectInsBasicInfoArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ServeOnWorkerCollectInsBasicInfoArgs(%+v)", *p)
}

// Attributes:
//   - Success
type ServeOnWorkerCollectInsBasicInfoResult struct {
	Success *PartitionInsBasic `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewServeOnWorkerCollectInsBasicInfoResult() *ServeOnWorkerCollectInsBasicInfoResult {
	return &ServeOnWorkerCollectInsBasicInfoResult{}
}

var ServeOnWorkerCollectInsBasicInfoResult_Success_DEFAULT *PartitionInsBasic

func (p *ServeOnWorkerCollectInsBasicInfoResult) GetSuccess() *PartitionInsBasic {
	if !p.IsSetSuccess() {
		return ServeOnWorkerCollectInsBasicInfoResult_Success_DEFAULT
	}
	return p.Success
}
func (p *ServeOnWorkerCollectInsBasicInfoResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ServeOnWorkerCollectInsBasicInfoResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ServeOnWorkerCollectInsBasicInfoResult) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.Success = &PartitionInsBasic{}
	if err := p.Success.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *ServeOnWorkerCollectInsBasicInfoResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "CollectInsBasicInfo_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ServeOnWorkerCollectInsBasicInfoResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *ServeOnWorkerCollectInsBasicInfoResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ServeOnWorkerCollectInsBasicInfoResult(%+v)", *p)
}

// Attributes:
//   - NonNaNlabelWeights
type ServeOnWorkerBeforeGenAVCArgs struct {
	NonNaNlabelWeights map[int32]map[float64]float64 `thrift:"nonNaNlabelWeights,1" db:"nonNaNlabelWeights" json:"nonNaNlabelWeights"`
}

func NewServeOnWorkerBeforeGenAVCArgs() *ServeOnWorkerBeforeGenAVCArgs {
	return &ServeOnWorkerBeforeGenAVCArgs{}
}

func (p *ServeOnWorkerBeforeGenAVCArgs) GetNonNaNlabelWeights() map[int32]map[float64]float64 {
	return p.NonNaNlabelWeights
}
func (p *ServeOnWorkerBeforeGenAVCArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.MAP {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ServeOnWorkerBeforeGenAVCArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading map begin: ", err)
	}
	tMap := make(map[int32]map[float64]float64, size)
	p.NonNaNlabelWeights = tMap
	for i := 0; i < size; i++ {
		var _key97 int32
		if v, err := iprot.ReadI32(ctx); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_key97 = v
		}
		_, _, size, err := iprot.ReadMapBegin(ctx)
		if err != nil {
			return thrift.PrependError("error reading map begin: ", err)
		}
		tMap := make(map[float64]float64, size)
		_val98 := tMap
		for i := 0; i < size; i++ {
			var _key99 float64
			if v, err := iprot.ReadDouble(ctx); err != nil {
				return thrift.PrependError("error reading field 0: ", err)
			} else {
				_key99 = v
			}
			var _val100 float64
			if v, err := iprot.ReadDouble(ctx); err != nil {
				return thrift.PrependError("error reading field 0: ", err)
			} else {
				_val100 = v
			}
			_val98[_key99] = _val100
		}
		if err := iprot.ReadMapEnd(ctx); err != nil {
			return thrift.PrependError("error reading map end: ", err)
		}
		p.NonNaNlabelWeights[_key97] = _val98
	}
	if err := iprot.ReadMapEnd(ctx); err != nil {
		return thrift.PrependError("error reading map end: ", err)
	}
	return nil
}

func (p *ServeOnWorkerBeforeGenAVCArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "BeforeGenAVC_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ServeOnWorkerBeforeGenAVCArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "nonNaNlabelWeights", thrift.MAP, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:nonNaNlabelWeights: ", p), err)
	}
	if err := oprot.WriteMapBegin(ctx, thrift.I32, thrift.MAP, len(p.NonNaNlabelWeights)); err != nil {
		return thrift.PrependError("error writing map begin: ", err)
	}
	for k, v := range p.NonNaNlabelWeights {
		if err := oprot.WriteI32(ctx, int32(k)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
		}
		if err := oprot.WriteMapBegin(ctx, thrift.DOUBLE, thrift.DOUBLE, len(v)); err != nil {
			return thrift.PrependError("error writing map begin: ", err)
		}
		for k, v := range v {
			if err := oprot.WriteDouble(ctx, float64(k)); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
			}
			if err := oprot.WriteDouble(ctx, float64(v)); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
			}
		}
		if err := oprot.WriteMapEnd(ctx); err != nil {
			return thrift.PrependError("error writing map end: ", err)
		}
	}
	if err := oprot.WriteMapEnd(ctx); err != nil {
		return thrift.PrependError("error writing map end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:nonNaNlabelWeights: ", p), err)
	}
	return err
}

func (p *ServeOnWorkerBeforeGenAVCArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ServeOnWorkerBeforeGenAVCArgs(%+v)", *p)
}

type ServeOnWorkerBeforeGenAVCResult struct {
}

func NewServeOnWorkerBeforeGenAVCResult() *ServeOnWorkerBeforeGenAVCResult {
	return &ServeOnWorkerBeforeGenAVCResult{}
}

func (p *ServeOnWorkerBeforeGenAVCResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.Skip(ctx, fieldTypeId); err != nil {
			return err
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ServeOnWorkerBeforeGenAVCResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "BeforeGenAVC_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ServeOnWorkerBeforeGenAVCResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ServeOnWorkerBeforeGenAVCResult(%+v)", *p)
}

type ServeOnWorkerAfterSplitArgs struct {
}

func NewServeOnWorkerAfterSplitArgs() *ServeOnWorkerAfterSplitArgs {
	return &ServeOnWorkerAfterSplitArgs{}
}

func (p *ServeOnWorkerAfterSplitArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.Skip(ctx, fieldTypeId); err != nil {
			return err
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ServeOnWorkerAfterSplitArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "AfterSplit_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ServeOnWorkerAfterSplitArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ServeOnWorkerAfterSplitArgs(%+v)", *p)
}

type ServeOnWorkerAfterSplitResult struct {
}

func NewServeOnWorkerAfterSplitResult() *ServeOnWorkerAfterSplitResult {
	return &ServeOnWorkerAfterSplitResult{}
}

func (p *ServeOnWorkerAfterSplitResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.Skip(ctx, fieldTypeId); err != nil {
			return err
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ServeOnWorkerAfterSplitResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "AfterSplit_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ServeOnWorkerAfterSplitResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ServeOnWorkerAfterSplitResult(%+v)", *p)
}

// Attributes:
//   - Partition
//   - SmallAVCTasks
//   - ConciseAVCTasks
type ServeOnWorkerGenGeneralAVCArgs struct {
	Partition       *PartitionRef       `thrift:"partition,1" db:"partition" json:"partition"`
	SmallAVCTasks   map[int32][]float64 `thrift:"smallAVCTasks,2" db:"smallAVCTasks" json:"smallAVCTasks"`
	ConciseAVCTasks map[int32][]float64 `thrift:"conciseAVCTasks,3" db:"conciseAVCTasks" json:"conciseAVCTasks"`
}

func NewServeOnWorkerGenGeneralAVCArgs() *ServeOnWorkerGenGeneralAVCArgs {
	return &ServeOnWorkerGenGeneralAVCArgs{}
}

var ServeOnWorkerGenGeneralAVCArgs_Partition_DEFAULT *PartitionRef

func (p *ServeOnWorkerGenGeneralAVCArgs) GetPartition() *PartitionRef {
	if !p.IsSetPartition() {
		return ServeOnWorkerGenGeneralAVCArgs_Partition_DEFAULT
	}
	return p.Partition
}

func (p *ServeOnWorkerGenGeneralAVCArgs) GetSmallAVCTasks() map[int32][]float64 {
	return p.SmallAVCTasks
}

func (p *ServeOnWorkerGenGeneralAVCArgs) GetConciseAVCTasks() map[int32][]float64 {
	return p.ConciseAVCTasks
}
func (p *ServeOnWorkerGenGeneralAVCArgs) IsSetPartition() bool {
	return p.Partition != nil
}

func (p *ServeOnWorkerGenGeneralAVCArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.MAP {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.MAP {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ServeOnWorkerGenGeneralAVCArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Partition = &PartitionRef{}
	if err := p.Partition.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Partition), err)
	}
	return nil
}

func (p *ServeOnWorkerGenGeneralAVCArgs) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading map begin: ", err)
	}
	tMap := make(map[int32][]float64, size)
	p.SmallAVCTasks = tMap
	for i := 0; i < size; i++ {
		var _key101 int32
		if v, err := iprot.ReadI32(ctx); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_key101 = v
		}
		_, size, err := iprot.ReadListBegin(ctx)
		if err != nil {
			return thrift.PrependError("error reading list begin: ", err)
		}
		tSlice := make([]float64, 0, size)
		_val102 := tSlice
		for i := 0; i < size; i++ {
			var _elem103 float64
			if v, err := iprot.ReadDouble(ctx); err != nil {
				return thrift.PrependError("error reading field 0: ", err)
			} else {
				_elem103 = v
			}
			_val102 = append(_val102, _elem103)
		}
		if err := iprot.ReadListEnd(ctx); err != nil {
			return thrift.PrependError("error reading list end: ", err)
		}
		p.SmallAVCTasks[_key101] = _val102
	}
	if err := iprot.ReadMapEnd(ctx); err != nil {
		return thrift.PrependError("error reading map end: ", err)
	}
	return nil
}

func (p *ServeOnWorkerGenGeneralAVCArgs) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading map begin: ", err)
	}
	tMap := make(map[int32][]float64, size)
	p.ConciseAVCTasks = tMap
	for i := 0; i < size; i++ {
		var _key104 int32
		if v, err := iprot.ReadI32(ctx); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_key104 = v
		}
		_, size, err := iprot.ReadListBegin(ctx)
		if err != nil {
			return thrift.PrependError("error reading list begin: ", err)
		}
		tSlice := make([]float64, 0, size)
		_val105 := tSlice
		for i := 0; i < size; i++ {
			var _elem106 float64
			if v, err := iprot.ReadDouble(ctx); err != nil {
				return thrift.PrependError("error reading field 0: ", err)
			} else {
				_elem106 = v
			}
			_val105 = append(_val105, _elem106)
		}
		if err := iprot.ReadListEnd(ctx); err != nil {
			return thrift.PrependError("error reading list end: ", err)
		}
		p.ConciseAVCTasks[_key104] = _val105
	}
	if err := iprot.ReadMapEnd(ctx); err != nil {
		return thrift.PrependError("error reading map end: ", err)
	}
	return nil
}

func (p *ServeOnWorkerGenGeneralAVCArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "GenGeneralAVC_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField3(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ServeOnWorkerGenGeneralAVCArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "partition", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:partition: ", p), err)
	}
	if err := p.Partition.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Partition), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:partition: ", p), err)
	}
	return err
}

func (p *ServeOnWorkerGenGeneralAVCArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "smallAVCTasks", thrift.MAP, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:smallAVCTasks: ", p), err)
	}
	if err := oprot.WriteMapBegin(ctx, thrift.I32, thrift.LIST, len(p.SmallAVCTasks)); err != nil {
		return thrift.PrependError("error writing map begin: ", err)
	}
	for k, v := range p.SmallAVCTasks {
		if err := oprot.WriteI32(ctx, int32(k)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
		}
		if err := oprot.WriteListBegin(ctx, thrift.DOUBLE, len(v)); err != nil {
			return thrift.PrependError("error writing list begin: ", err)
		}
		for _, v := range v {
			if err := oprot.WriteDouble(ctx, float64(v)); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
			}
		}
		if err := oprot.WriteListEnd(ctx); err != nil {
			return thrift.PrependError("error writing list end: ", err)
		}
	}
	if err := oprot.WriteMapEnd(ctx); err != nil {
		return thrift.PrependError("error writing map end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:smallAVCTasks: ", p), err)
	}
	return err
}

func (p *ServeOnWorkerGenGeneralAVCArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "conciseAVCTasks", thrift.MAP, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:conciseAVCTasks: ", p), err)
	}
	if err := oprot.WriteMapBegin(ctx, thrift.I32, thrift.LIST, len(p.ConciseAVCTasks)); err != nil {
		return thrift.PrependError("error writing map begin: ", err)
	}
	for k, v := range p.ConciseAVCTasks {
		if err := oprot.WriteI32(ctx, int32(k)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
		}
		if err := oprot.WriteListBegin(ctx, thrift.DOUBLE, len(v)); err != nil {
			return thrift.PrependError("error writing list begin: ", err)
		}
		for _, v := range v {
			if err := oprot.WriteDouble(ctx, float64(v)); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
			}
		}
		if err := oprot.WriteListEnd(ctx); err != nil {
			return thrift.PrependError("error writing list end: ", err)
		}
	}
	if err := oprot.WriteMapEnd(ctx); err != nil {
		return thrift.PrependError("error writing map end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:conciseAVCTasks: ", p), err)
	}
	return err
}

func (p *ServeOnWorkerGenGeneralAVCArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ServeOnWorkerGenGeneralAVCArgs(%+v)", *p)
}

type ServeOnWorkerGenGeneralAVCResult struct {
}

func NewServeOnWorkerGenGeneralAVCResult() *ServeOnWorkerGenGeneralAVCResult {
	return &ServeOnWorkerGenGeneralAVCResult{}
}

func (p *ServeOnWorkerGenGeneralAVCResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.Skip(ctx, fieldTypeId); err != nil {
			return err
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ServeOnWorkerGenGeneralAVCResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "GenGeneralAVC_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ServeOnWorkerGenGeneralAVCResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ServeOnWorkerGenGeneralAVCResult(%+v)", *p)
}

// Attributes:
//   - Partition
//   - FeatureId
//   - Tasks
type ServeOnWorkerGenPartialAVCArgs struct {
	Partition *PartitionRef `thrift:"partition,1" db:"partition" json:"partition"`
	FeatureId int32         `thrift:"featureId,2" db:"featureId" json:"featureId"`
	Tasks     []*Interval   `thrift:"tasks,3" db:"tasks" json:"tasks"`
}

func NewServeOnWorkerGenPartialAVCArgs() *ServeOnWorkerGenPartialAVCArgs {
	return &ServeOnWorkerGenPartialAVCArgs{}
}

var ServeOnWorkerGenPartialAVCArgs_Partition_DEFAULT *PartitionRef

func (p *ServeOnWorkerGenPartialAVCArgs) GetPartition() *PartitionRef {
	if !p.IsSetPartition() {
		return ServeOnWorkerGenPartialAVCArgs_Partition_DEFAULT
	}
	return p.Partition
}

func (p *ServeOnWorkerGenPartialAVCArgs) GetFeatureId() int32 {
	return p.FeatureId
}

func (p *ServeOnWorkerGenPartialAVCArgs) GetTasks() []*Interval {
	return p.Tasks
}
func (p *ServeOnWorkerGenPartialAVCArgs) IsSetPartition() bool {
	return p.Partition != nil
}

func (p *ServeOnWorkerGenPartialAVCArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ServeOnWorkerGenPartialAVCArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Partition = &PartitionRef{}
	if err := p.Partition.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Partition), err)
	}
	return nil
}

func (p *ServeOnWorkerGenPartialAVCArgs) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.FeatureId = v
	}
	return nil
}

func (p *ServeOnWorkerGenPartialAVCArgs) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*Interval, 0, size)
	p.Tasks = tSlice
	for i := 0; i < size; i++ {
		_elem107 := &Interval{}
		if err := _elem107.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem107), err)
		}
		p.Tasks = append(p.Tasks, _elem107)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *ServeOnWorkerGenPartialAVCArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "GenPartialAVC_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField3(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ServeOnWorkerGenPartialAVCArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "partition", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:partition: ", p), err)
	}
	if err := p.Partition.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Partition), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:partition: ", p), err)
	}
	return err
}

func (p *ServeOnWorkerGenPartialAVCArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "featureId", thrift.I32, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:featureId: ", p), err)
	}
	if err := oprot.WriteI32(ctx, int32(p.FeatureId)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.featureId (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:featureId: ", p), err)
	}
	return err
}

func (p *ServeOnWorkerGenPartialAVCArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "tasks", thrift.LIST, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:tasks: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Tasks)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.Tasks {
		if err := v.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:tasks: ", p), err)
	}
	return err
}

func (p *ServeOnWorkerGenPartialAVCArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ServeOnWorkerGenPartialAVCArgs(%+v)", *p)
}

// Attributes:
//   - Success
type ServeOnWorkerGenPartialAVCResult struct {
	Success []*AVC `thrift:"success,0" db:"success" json:"success,omitempty"`
}

func NewServeOnWorkerGenPartialAVCResult() *ServeOnWorkerGenPartialAVCResult {
	return &ServeOnWorkerGenPartialAVCResult{}
}

var ServeOnWorkerGenPartialAVCResult_Success_DEFAULT []*AVC

func (p *ServeOnWorkerGenPartialAVCResult) GetSuccess() []*AVC {
	return p.Success
}
func (p *ServeOnWorkerGenPartialAVCResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ServeOnWorkerGenPartialAVCResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ServeOnWorkerGenPartialAVCResult) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*AVC, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem108 := &AVC{}
		if err := _elem108.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem108), err)
		}
		p.Success = append(p.Success, _elem108)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *ServeOnWorkerGenPartialAVCResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "GenPartialAVC_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ServeOnWorkerGenPartialAVCResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.LIST, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Success)); err != nil {
			return thrift.PrependError("error writing list begin: ", err)
		}
		for _, v := range p.Success {
			if err := v.Write(ctx, oprot); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
			}
		}
		if err := oprot.WriteListEnd(ctx); err != nil {
			return thrift.PrependError("error writing list end: ", err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *ServeOnWorkerGenPartialAVCResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ServeOnWorkerGenPartialAVCResult(%+v)", *p)
}

// Attributes:
//   - Partition
//   - NewPartitionId_
//   - SplitAttr
//   - SplitValue
//   - HasNaN
type ServeOnWorkerSplitArgs struct {
	Partition       *PartitionRef `thrift:"partition,1" db:"partition" json:"partition"`
	NewPartitionId_ int64         `thrift:"newPartitionId,2" db:"newPartitionId" json:"newPartitionId"`
	SplitAttr       int32         `thrift:"splitAttr,3" db:"splitAttr" json:"splitAttr"`
	SplitValue      float64       `thrift:"splitValue,4" db:"splitValue" json:"splitValue"`
	HasNaN          bool          `thrift:"hasNaN,5" db:"hasNaN" json:"hasNaN"`
}

func NewServeOnWorkerSplitArgs() *ServeOnWorkerSplitArgs {
	return &ServeOnWorkerSplitArgs{}
}

var ServeOnWorkerSplitArgs_Partition_DEFAULT *PartitionRef

func (p *ServeOnWorkerSplitArgs) GetPartition() *PartitionRef {
	if !p.IsSetPartition() {
		return ServeOnWorkerSplitArgs_Partition_DEFAULT
	}
	return p.Partition
}

func (p *ServeOnWorkerSplitArgs) GetNewPartitionId_() int64 {
	return p.NewPartitionId_
}

func (p *ServeOnWorkerSplitArgs) GetSplitAttr() int32 {
	return p.SplitAttr
}

func (p *ServeOnWorkerSplitArgs) GetSplitValue() float64 {
	return p.SplitValue
}

func (p *ServeOnWorkerSplitArgs) GetHasNaN() bool {
	return p.HasNaN
}
func (p *ServeOnWorkerSplitArgs) IsSetPartition() bool {
	return p.Partition != nil
}

func (p *ServeOnWorkerSplitArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 4:
			if fieldTypeId == thrift.DOUBLE {
				if err := p.ReadField4(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 5:
			if fieldTypeId == thrift.BOOL {
				if err := p.ReadField5(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ServeOnWorkerSplitArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Partition = &PartitionRef{}
	if err := p.Partition.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Partition), err)
	}
	return nil
}

func (p *ServeOnWorkerSplitArgs) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.NewPartitionId_ = v
	}
	return nil
}

func (p *ServeOnWorkerSplitArgs) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.SplitAttr = v
	}
	return nil
}

func (p *ServeOnWorkerSplitArgs) ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadDouble(ctx); err != nil {
		return thrift.PrependError("error reading field 4: ", err)
	} else {
		p.SplitValue = v
	}
	return nil
}

func (p *ServeOnWorkerSplitArgs) ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(ctx); err != nil {
		return thrift.PrependError("error reading field 5: ", err)
	} else {
		p.HasNaN = v
	}
	return nil
}

func (p *ServeOnWorkerSplitArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "Split_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField3(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField4(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField5(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ServeOnWorkerSplitArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "partition", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:partition: ", p), err)
	}
	if err := p.Partition.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Partition), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:partition: ", p), err)
	}
	return err
}

func (p *ServeOnWorkerSplitArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "newPartitionId", thrift.I64, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:newPartitionId: ", p), err)
	}
	if err := oprot.WriteI64(ctx, int64(p.NewPartitionId_)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.newPartitionId (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:newPartitionId: ", p), err)
	}
	return err
}

func (p *ServeOnWorkerSplitArgs) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "splitAttr", thrift.I32, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:splitAttr: ", p), err)
	}
	if err := oprot.WriteI32(ctx, int32(p.SplitAttr)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.splitAttr (3) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:splitAttr: ", p), err)
	}
	return err
}

func (p *ServeOnWorkerSplitArgs) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "splitValue", thrift.DOUBLE, 4); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:splitValue: ", p), err)
	}
	if err := oprot.WriteDouble(ctx, float64(p.SplitValue)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.splitValue (4) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 4:splitValue: ", p), err)
	}
	return err
}

func (p *ServeOnWorkerSplitArgs) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "hasNaN", thrift.BOOL, 5); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:hasNaN: ", p), err)
	}
	if err := oprot.WriteBool(ctx, bool(p.HasNaN)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.hasNaN (5) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 5:hasNaN: ", p), err)
	}
	return err
}

func (p *ServeOnWorkerSplitArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ServeOnWorkerSplitArgs(%+v)", *p)
}

type ServeOnWorkerSplitResult struct {
}

func NewServeOnWorkerSplitResult() *ServeOnWorkerSplitResult {
	return &ServeOnWorkerSplitResult{}
}

func (p *ServeOnWorkerSplitResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.Skip(ctx, fieldTypeId); err != nil {
			return err
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ServeOnWorkerSplitResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "Split_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ServeOnWorkerSplitResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ServeOnWorkerSplitResult(%+v)", *p)
}

// Attributes:
//   - Partition
//   - Avc
type ServeOnWorkerMergeGeneralAVCArgs struct {
	Partition *PartitionRef `thrift:"partition,1" db:"partition" json:"partition"`
	Avc       *AVC          `thrift:"avc,2" db:"avc" json:"avc"`
}

func NewServeOnWorkerMergeGeneralAVCArgs() *ServeOnWorkerMergeGeneralAVCArgs {
	return &ServeOnWorkerMergeGeneralAVCArgs{}
}

var ServeOnWorkerMergeGeneralAVCArgs_Partition_DEFAULT *PartitionRef

func (p *ServeOnWorkerMergeGeneralAVCArgs) GetPartition() *PartitionRef {
	if !p.IsSetPartition() {
		return ServeOnWorkerMergeGeneralAVCArgs_Partition_DEFAULT
	}
	return p.Partition
}

var ServeOnWorkerMergeGeneralAVCArgs_Avc_DEFAULT *AVC

func (p *ServeOnWorkerMergeGeneralAVCArgs) GetAvc() *AVC {
	if !p.IsSetAvc() {
		return ServeOnWorkerMergeGeneralAVCArgs_Avc_DEFAULT
	}
	return p.Avc
}
func (p *ServeOnWorkerMergeGeneralAVCArgs) IsSetPartition() bool {
	return p.Partition != nil
}

func (p *ServeOnWorkerMergeGeneralAVCArgs) IsSetAvc() bool {
	return p.Avc != nil
}

func (p *ServeOnWorkerMergeGeneralAVCArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ServeOnWorkerMergeGeneralAVCArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Partition = &PartitionRef{}
	if err := p.Partition.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Partition), err)
	}
	return nil
}

func (p *ServeOnWorkerMergeGeneralAVCArgs) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.Avc = &AVC{}
	if err := p.Avc.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Avc), err)
	}
	return nil
}

func (p *ServeOnWorkerMergeGeneralAVCArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "MergeGeneralAVC_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil {
			return err
		}
		if err := p.writeField2(ctx, oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ServeOnWorkerMergeGeneralAVCArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "partition", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:partition: ", p), err)
	}
	if err := p.Partition.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Partition), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:partition: ", p), err)
	}
	return err
}

func (p *ServeOnWorkerMergeGeneralAVCArgs) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "avc", thrift.STRUCT, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:avc: ", p), err)
	}
	if err := p.Avc.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Avc), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:avc: ", p), err)
	}
	return err
}

func (p *ServeOnWorkerMergeGeneralAVCArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ServeOnWorkerMergeGeneralAVCArgs(%+v)", *p)
}

type ServeOnWorkerMergeGeneralAVCResult struct {
}

func NewServeOnWorkerMergeGeneralAVCResult() *ServeOnWorkerMergeGeneralAVCResult {
	return &ServeOnWorkerMergeGeneralAVCResult{}
}

func (p *ServeOnWorkerMergeGeneralAVCResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.Skip(ctx, fieldTypeId); err != nil {
			return err
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ServeOnWorkerMergeGeneralAVCResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "MergeGeneralAVC_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ServeOnWorkerMergeGeneralAVCResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ServeOnWorkerMergeGeneralAVCResult(%+v)", *p)
}

type ServeOnWorkerClearArgs struct {
}

func NewServeOnWorkerClearArgs() *ServeOnWorkerClearArgs {
	return &ServeOnWorkerClearArgs{}
}

func (p *ServeOnWorkerClearArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.Skip(ctx, fieldTypeId); err != nil {
			return err
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ServeOnWorkerClearArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "Clear_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ServeOnWorkerClearArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ServeOnWorkerClearArgs(%+v)", *p)
}

type ServeOnWorkerClearResult struct {
}

func NewServeOnWorkerClearResult() *ServeOnWorkerClearResult {
	return &ServeOnWorkerClearResult{}
}

func (p *ServeOnWorkerClearResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.Skip(ctx, fieldTypeId); err != nil {
			return err
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ServeOnWorkerClearResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "Clear_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ServeOnWorkerClearResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ServeOnWorkerClearResult(%+v)", *p)
}

type ServeOnWorkerStopArgs struct {
}

func NewServeOnWorkerStopArgs() *ServeOnWorkerStopArgs {
	return &ServeOnWorkerStopArgs{}
}

func (p *ServeOnWorkerStopArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.Skip(ctx, fieldTypeId); err != nil {
			return err
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ServeOnWorkerStopArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "Stop_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ServeOnWorkerStopArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ServeOnWorkerStopArgs(%+v)", *p)
}

type ServeOnWorkerStopResult struct {
}

func NewServeOnWorkerStopResult() *ServeOnWorkerStopResult {
	return &ServeOnWorkerStopResult{}
}

func (p *ServeOnWorkerStopResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.Skip(ctx, fieldTypeId); err != nil {
			return err
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ServeOnWorkerStopResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "Stop_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ServeOnWorkerStopResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ServeOnWorkerStopResult(%+v)", *p)
}
